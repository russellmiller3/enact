 VISA POC ONE-PAGER: WHAT TO BUILD & WHY

## THE DEMO (Work Backwards From This)

**Duration:** 90 seconds  
**What they see:** You type a request â†’ 5 agents execute â†’ access granted with audit trail  
**What they remember:** "This person understands our problem and can ship"

---

## DEMO SCRIPT (Memorize This)

**[Screen share Gradio UI]**

"This automates data access requests in the GDO. Watch:"

**[Type request, hit Run]**

"Five agents executing:
1. Intake parsed the request
2. Policy checked compliance - auto-approved
3. Provisioning granted 90-day access  
4. Notifications sent
5. Full audit trail generated

2 minutes vs 2-5 days. $780k/year ROI. Scales to all GDO workflows."

**[Show audit trail JSON]**

"Every decision logged for compliance. That's the game."

---

## MOCK REQUEST & RESPONSE

### Request 1: Auto-Approve (Use This in Demo)
```
I need read access to fraud_detection_models dataset to analyze 
Q1 false positive rates for my risk analysis project.
```

**What happens:**
- Intake extracts: requester, dataset=fraud_detection_models, access_level=read
- Policy checks: read access + valid justification = APPROVE
- Provision grants: token visa-token-82471, expires 2026-05-15
- Notify sends: 2 emails (requester + manager)
- Audit logs: 5 entries with timestamps

**Why this request:** 
- Read-only (low risk, auto-approve)
- Fraud dataset (relevant to Visa/Matt Foreman)
- Clear business justification
- No PII triggers

---

### Request 2: Escalation (Show Governance)
```
I need write access to customer_pii_cardholder_data to update 
records for GDPR compliance audit.
```

**What happens:**
- Intake extracts: dataset contains "pii" and "cardholder", access_level=write
- Policy checks: PII dataset + write access = ESCALATE to manager
- Workflow pauses: "Manager notified for approval"
- Shows: Human-in-the-loop governance

**Why this request:**
- Triggers PII policy (governance showcase)
- Write access requires approval (not auto)
- Shows the system is smart, not rubber-stamping

---

### Request 3: Denial (Optional, Time Permitting)
```
Give me admin access to all datasets for testing.
```

**What happens:**
- Policy checks: No justification + admin access = DENY
- Workflow terminates: "Request denied - insufficient justification"

**Why this request:**
- Shows policy enforcement works
- Bad actor protection

---

## TOY POLICIES (Keep It Simple)

### 5 Rules to Encode

```python
POLICIES = {
    "pii_datasets": {
        "keywords": ["pii", "customer", "cardholder", "personal"],
        "rule": "Requires compliance training + manager approval for write/admin"
    },
    "read_access": {
        "rule": "Auto-approve if valid justification provided"
    },
    "write_access": {
        "rule": "Escalate to manager approval"
    },
    "admin_access": {
        "rule": "Escalate to director approval"
    },
    "access_duration": {
        "rule": "Maximum 90 days, then auto-expire"
    }
}
```

**Why these policies:**
- Realistic for financial services
- Easy to explain in 30 seconds
- Cover common governance patterns (PII, role-based access, time limits)

---

## MOCK SYSTEMS TO PROVISION

### 3 Fake Datasets (Good Enough for Demo)

```python
DATASETS = {
    "fraud_detection_models": {
        "sensitivity": "internal",
        "contains_pii": False,
        "description": "ML models for transaction fraud scoring"
    },
    "customer_pii_cardholder_data": {
        "sensitivity": "restricted",
        "contains_pii": True,
        "description": "Cardholder personal information"
    },
    "sales_dashboard_data": {
        "sensitivity": "internal", 
        "contains_pii": False,
        "description": "Aggregated merchant sales metrics"
    }
}
```

**Mock provisioning response:**
```json
{
    "status": "SUCCESS",
    "access_token": "visa-token-82471",
    "dataset": "fraud_detection_models",
    "requester": "analyst@visa.com",
    "access_level": "read",
    "granted_at": "2026-02-15 15:30:00",
    "expires_at": "2026-05-15"
}
```

**Why mock:** 
- No real IAM integration needed
- Shows you understand the contract
- "In production this calls Okta/AWS IAM" is sufficient

---

## BUILD PRIORITY (4 Hours, But Really 3)

### Hour 1: LangGraph Skeleton (The Hard Part)
**Goal:** Get the state machine working with print statements

```python
from langgraph.graph import StateGraph, END

# Define state
class State(TypedDict):
    request: str
    intake: dict
    policy: dict
    provision: dict
    audit: list

# Define nodes (just print for now)
def intake_node(state):
    print("Intake running...")
    return {"intake": {"dataset": "fraud_detection_models"}}

def policy_node(state):
    print("Policy running...")
    return {"policy": {"decision": "APPROVE"}}

# Build graph
graph = StateGraph(State)
graph.add_node("intake", intake_node)
graph.add_node("policy", policy_node)
graph.add_edge("intake", "policy")
graph.set_entry_point("intake")

app = graph.compile()

# Test it
result = app.invoke({"request": "I need access", "audit": []})
print(result)
```

**Milestone:** Graph executes without errors. Prints show agent flow.

---

### Hour 2: Real Agent Logic (The LLM Calls)
**Goal:** Replace print statements with actual LLM calls

```python
from langchain_openai import ChatOpenAI
import json

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

def intake_node(state):
    prompt = f"""Extract JSON from: {state['request']}
    Return: {{"requester": "...", "dataset": "...", "access_level": "read/write/admin", "justification": "..."}}"""
    
    result = llm.invoke(prompt)
    # Parse JSON from result.content
    import re
    json_match = re.search(r'\\{.*\\}', result.content, re.DOTALL)
    intake_data = json.loads(json_match.group()) if json_match else {}
    
    return {"intake": intake_data}

def policy_node(state):
    intake = state['intake']
    dataset = intake.get('dataset', '')
    access = intake.get('access_level', '')
    
    # Simple rule engine (no LLM needed here)
    if 'pii' in dataset.lower() or 'cardholder' in dataset.lower():
        if access in ['write', 'admin']:
            return {"policy": {"decision": "ESCALATE", "reason": "PII dataset requires approval"}}
    
    if access == 'admin':
        return {"policy": {"decision": "ESCALATE", "reason": "Admin access requires director approval"}}
    
    if access == 'read' and len(intake.get('justification', '')) > 10:
        return {"policy": {"decision": "APPROVE", "reason": "Read access with valid justification"}}
    
    return {"policy": {"decision": "DENY", "reason": "Insufficient justification"}}
```

**Milestone:** Can paste Request 1 â†’ get structured intake â†’ get APPROVE decision

---

### Hour 3: Gradio Frontend (The Easy Part)
**Goal:** Wrap it in a UI

```python
import gradio as gr

def run_demo(request_text):
    result = app.invoke({
        "request": request_text,
        "audit": []
    })
    
    # Format output
    output = f"""
## Intake Agent
{json.dumps(result['intake'], indent=2)}

## Policy Agent  
Decision: {result['policy']['decision']}
Reason: {result['policy']['reason']}

## Provisioning
{json.dumps(result.get('provision', {}), indent=2) if result['policy']['decision'] == 'APPROVE' else 'N/A - Escalated'}
"""
    return output

demo = gr.Interface(
    fn=run_demo,
    inputs=gr.Textbox(label="Request", lines=3),
    outputs=gr.Markdown(label="Workflow"),
    title="Visa GDO Data Access Automation"
)

demo.launch(share=True)
```

**Milestone:** Gradio opens, you paste Request 1, it shows formatted output

---

## WHAT TO CUT IF SHORT ON TIME

**Cut this:**
- âŒ Notification Agent (just say "emails would be sent here")
- âŒ Pretty formatting (Markdown vs plain text doesn't matter)
- âŒ Error handling (it's a demo, not production)
- âŒ Request 3 (denial case - nice to have, not critical)

**Never cut:**
- âœ… LangGraph (the whole point)
- âœ… LLM call for Intake (shows AI)
- âœ… Policy enforcement (governance showcase)
- âœ… Audit trail (governance showcase)
- âœ… Request 1 + 2 (approve + escalate)

---

## THE ABSOLUTE MINIMUM VIABLE DEMO

If you only have 2 hours:

**3 nodes, 2 test cases:**
1. **Intake Node:** LLM parses request â†’ JSON
2. **Policy Node:** Python rules â†’ APPROVE/ESCALATE
3. **Provision Node:** Return mock token

**Gradio:** Text input â†’ Markdown output showing all 3 steps

**Demo:** Paste Request 1 (approve), then Request 2 (escalate)

**Talking points:** 
- "This is the architecture pattern"
- "In production: real IAM, notification systems, approval UI"
- "Governance built in: policy checks before execution, audit logs, time-limited access"

**That's enough to win.**

---

## DEMO FLOW (What They See)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“ Data Access Request                     â”‚
â”‚                                             â”‚
â”‚  I need read access to                      â”‚
â”‚  fraud_detection_models dataset             â”‚
â”‚  to analyze Q1 false positive rates         â”‚
â”‚  for my risk analysis project.              â”‚
â”‚                                             â”‚
â”‚          [ğŸš€ Run Workflow]                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â†“ (2 seconds)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ¤– WORKFLOW LOG                            â”‚
â”‚                                             â”‚
â”‚  ğŸ“¥ Intake Agent                            â”‚
â”‚  âœ… Extracted:                              â”‚
â”‚     â€¢ Dataset: fraud_detection_models       â”‚
â”‚     â€¢ Access: read                          â”‚
â”‚     â€¢ Justification: Q1 false positive...   â”‚
â”‚                                             â”‚
â”‚  ğŸ›¡ï¸ Policy Agent                            â”‚
â”‚  âœ… Decision: APPROVE                       â”‚
â”‚     Reason: Read access with valid          â”‚
â”‚     justification                           â”‚
â”‚                                             â”‚
â”‚  âš™ï¸ Provisioning Agent                      â”‚
â”‚  âœ… Access Granted:                         â”‚
â”‚     â€¢ Token: visa-token-82471               â”‚
â”‚     â€¢ Expires: 2026-05-15                   â”‚
â”‚                                             â”‚
â”‚  ğŸ“§ Notifications                           â”‚
â”‚  âœ… Email sent to analyst@visa.com          â”‚
â”‚  âœ… Email sent to manager@visa.com          â”‚
â”‚                                             â”‚
â”‚  âœ… COMPLETE: 2 min vs 2-5 days             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â†“ (click "View Audit Trail")

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ” AUDIT TRAIL (JSON)                      â”‚
â”‚                                             â”‚
â”‚  [                                          â”‚
â”‚    {                                        â”‚
â”‚      "timestamp": "2026-02-15T15:30:01",    â”‚
â”‚      "agent": "IntakeAgent",                â”‚
â”‚      "step": "parse_request",               â”‚
â”‚      "data": {...}                          â”‚
â”‚    },                                       â”‚
â”‚    {                                        â”‚
â”‚      "timestamp": "2026-02-15T15:30:02",    â”‚
â”‚      "agent": "PolicyAgent",                â”‚
â”‚      "decision": "APPROVE",                 â”‚
â”‚      "reasoning": "..."                     â”‚
â”‚    },                                       â”‚
â”‚    ...                                      â”‚
â”‚  ]                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## WHY THIS WINS

### For Matt Foreman (Data Science Guy)
- **Measurable:** $780k/year ROI
- **Rigorous:** Policy rules are explicit, testable
- **Fraud-adjacent:** Demo uses fraud dataset (his domain)

### For Harish Raghavendra (Engineering Guy)  
- **Buildable:** LangGraph is industry standard
- **Modular:** Agents are swappable components
- **Scalable:** State machine pattern works for 5 or 50 workflows

### For Both
- **Governance first:** Audit trails, policy enforcement, time limits
- **Real problem:** They've lived this pain 1,000 times
- **You shipped:** Working demo in one weekend

---

## FINAL CHECKLIST

**Before you code:**
- [ ] Read this doc twice
- [ ] Understand the 5 policies
- [ ] Memorize Request 1 and expected output

**While coding:**
- [ ] Test after each hour milestone
- [ ] Use Request 1 as your test case
- [ ] Don't add features - ship the MVP

**Before demo:**
- [ ] Run Request 1 (approve) - works?
- [ ] Run Request 2 (escalate) - works?
- [ ] Practice 90-second narration 3x
- [ ] Have backup screenshots

**During interview:**
- [ ] Lead with the problem ($780k/year)
- [ ] Show the demo (let it speak)
- [ ] Close with scalability (all GDO workflows)

---

## THE ONE SENTENCE PITCH

"I built a multi-agent system using LangGraph that automates GDO data access requests with full governance, cutting 2-5 days to 2 minutes â€” the same pattern scales to every workflow you want to transform."

**Now go build it. 3 hours. Ship it. Win the job.**
'''

with open('/tmp/visa_poc_one_pager.md', 'w') as f:
    f.write(one_pager)

print("âœ… One-pager created: visa_poc_one_pager.md")
print(f"ğŸ“„ Length: {len(one_pager)} characters")
print("\nğŸ¯ PRIORITY ORDER:")
print("1. Hour 1: LangGraph skeleton working")
print("2. Hour 2: Real LLM calls + policy logic")
print("3. Hour 3: Gradio wrapper")
print("\nğŸ’¡ DEMO REQUEST:")
print('   "I need read access to fraud_detection_models dataset')
print('    to analyze Q1 false positive rates for my risk analysis project."')
print("\nâœ… Expected: APPROVE â†’ Provision â†’ $780k/year ROI pitch")