# Rollback Feature Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add `EnactClient.rollback(run_id)` — given a receipt ID, reverse all successful actions from that run in reverse order, producing a new signed receipt.

**Architecture:** Each `ActionResult` gains a `rollback_data` dict field that connectors populate with pre-action state before mutating. The receipt then contains everything needed to undo. `EnactClient.rollback()` loads the receipt, iterates `actions_taken` in reverse, skips noops and failures, dispatches to per-connector inverse operations, and writes a new signed rollback receipt. Gated behind `rollback_enabled=True` (premium feature).

**Tech Stack:** Python 3.9+, Pydantic v2, PyGithub, psycopg2, pytest, unittest.mock

---

## A.1 What We're Building

**User-facing summary:** After this feature ships, an engineer (or agent) can call `client.rollback(run_id)` to undo a previous run in a single function call. Enact reverses each action in reverse order, skips what can't be undone (and records why), and produces a new signed rollback receipt proving exactly what happened.

```
BEFORE                                   AFTER
────────────────────────────────────────────────────────────────
Agent makes 3 GitHub + DB changes        Agent makes 3 GitHub + DB changes
Receipt logged, no undo button           Receipt logs pre-action state too

Something goes wrong...                  Something goes wrong...
Engineer digs through receipt            client.rollback(run_id)
Calls APIs manually                        → close_pr       (was: create_pr)
Hopes to reconstruct state                 → delete_branch  (was: create_branch)
No proof anything was reversed             → restore DB row (was: insert_row)
                                           → new signed rollback receipt
                                         Done. Provable.
```

**New capabilities delivered:**
1. `client.rollback(run_id)` — one-call undo, gated behind `rollback_enabled=True` (premium feature)
2. `rollback_data` on every `ActionResult` — pre-action state snapshot baked into all receipts going forward
3. Signed rollback receipt — proof of what was reversed and what could not be
4. New inverse GitHub actions: `close_pr`, `close_issue`, `create_branch_from_sha`

**Reversibility matrix — what can and cannot be undone:**

| System | Action | Reversible? | Inverse | Notes |
|--------|--------|-------------|---------|-------|
| github | `create_branch` | YES | `delete_branch` | |
| github | `delete_branch` | YES | `create_branch_from_sha` | SHA captured before deletion |
| github | `create_pr` | YES (close only) | `close_pr` | Can close, not delete |
| github | `create_issue` | YES (close only) | `close_issue` | Can close, not delete |
| github | `merge_pr` | **NO** | — | Can't unmerge; rollback receipt records this as failure |
| github | `push_commit` | **NO** | — | Can't un-push without destructive force; recorded as failure |
| postgres | `insert_row` | YES | `delete_row` | Uses `id` col or first col as PK |
| postgres | `update_row` | YES | `update_row` (old values) | Pre-SELECT captures previous state |
| postgres | `delete_row` | YES | `insert_row` | Pre-SELECT captures rows before deletion |
| postgres | `select_rows` | N/A (read-only) | — | Skipped — nothing to undo |

**Important:** Any connector action NOT in this table (e.g. future email sends, Slack messages) is treated as having no rollback handler. The rollback receipt will record `success=False` with a clear error message for those actions. This is intentional — irreversibility is a documented contract, not a silent failure.

**Critical design decision on partial rollback:** If a run had 3 actions and 1 was irreversible (`merge_pr`), `rollback()` returns `RunResult(success=False)` — signaling to the caller that the rollback was partial. The rollback receipt lists exactly which actions succeeded and which didn't, so the engineer knows what still needs manual cleanup.

---

## CRITICAL RULES

- Read PLAN-TEMPLATE.md critical rules before starting
- Tests and code change in the SAME step — never commit broken tests
- Run `pytest -v` after every cycle to confirm no regressions
- Current test count: 123 passing — must not drop

## Files Overview

| File | Change |
|---|---|
| `enact/models.py` | Add `rollback_data: dict` to `ActionResult`; add `"PARTIAL"` to `Receipt.decision` Literal |
| `enact/receipt.py` | Add `load_receipt()` function |
| `enact/connectors/github.py` | Populate `rollback_data` in existing methods; add `close_pr`, `close_issue`, `create_branch_from_sha` |
| `enact/connectors/postgres.py` | Pre-SELECT in `update_row`/`delete_row`; populate `rollback_data` in all mutating methods |
| `enact/rollback.py` | NEW — `execute_rollback_action()` dispatch logic |
| `enact/client.py` | Add `rollback_enabled` param + `rollback()` method |
| `tests/test_rollback.py` | NEW — 20 tests |
| `tests/test_github.py` | Add tests for 3 new methods + `rollback_data` assertions |
| `tests/test_postgres.py` | Add `rollback_data` assertions to existing mutating method tests |

---

## Cycle 1: Add `rollback_data` field to `ActionResult`

**Files:**
- Modify: `enact/models.py`
- Modify: `tests/test_receipt.py` (verify backward compat)

### Step 1: Write the failing test

Add to `tests/test_receipt.py` inside the existing test class:

```python
def test_action_result_has_rollback_data_field():
    """rollback_data defaults to empty dict — backward compatible."""
    result = ActionResult(action="create_branch", system="github", success=True, output={})
    assert result.rollback_data == {}

def test_action_result_rollback_data_can_be_set():
    result = ActionResult(
        action="create_branch",
        system="github",
        success=True,
        output={"branch": "agent/x"},
        rollback_data={"repo": "owner/repo", "branch": "agent/x"},
    )
    assert result.rollback_data["branch"] == "agent/x"

def test_receipt_decision_accepts_partial():
    """
    Receipt.decision Literal must include "PARTIAL" — rollback() sets this
    when some actions could not be reversed. Without it, Pydantic raises
    ValidationError and the rollback call crashes.
    """
    from enact.receipt import build_receipt, sign_receipt
    receipt = build_receipt(
        workflow="rollback:test_workflow",
        actor_email="agent@test.com",
        payload={"original_run_id": "abc", "rollback": True},
        policy_results=[],
        decision="PARTIAL",
    )
    assert receipt.decision == "PARTIAL"
```

### Step 2: Run test to verify it fails

```bash
pytest tests/test_receipt.py::test_action_result_has_rollback_data_field -v
```
Expected: `AttributeError` or `ValidationError` — `rollback_data` doesn't exist yet.

### Step 3: Update `enact/models.py` — two changes

**Change 1:** In the `ActionResult` class, after the `output` field (line ~88), add:

```python
    # Pre-action state needed to reverse this action at rollback time.
    # Connectors populate this before mutating. Empty dict = not reversible or read-only.
    rollback_data: dict = Field(default_factory=dict)
```

The full `ActionResult` class becomes:
```python
class ActionResult(BaseModel):
    action: str
    system: str
    success: bool
    output: dict = Field(default_factory=dict)
    rollback_data: dict = Field(default_factory=dict)  # NEW
```

**Change 2:** In the `Receipt` class, extend the `decision` Literal to include `"PARTIAL"`:

```python
    # "PASS" = all policies passed and workflow ran
    # "BLOCK" = at least one policy failed
    # "PARTIAL" = rollback ran but some actions could not be reversed (irreversible)
    decision: Literal["PASS", "BLOCK", "PARTIAL"]
```

**Why this matters:** `rollback()` sets `decision="PARTIAL"` when any rollback action fails (e.g., `merge_pr` is irreversible). Without this Literal update, Pydantic raises a `ValidationError` and the entire rollback call crashes. The landing page also shows "PARTIAL ROLLBACK" — this keeps the code consistent with the demo.

### Step 4: Run tests to verify they pass

```bash
pytest tests/test_receipt.py -v
pytest tests/ -v  # Verify no regressions — rollback_data defaults to {} everywhere
```
Expected: all tests pass (field is additive with default).

### Step 5: Commit

```bash
git add enact/models.py tests/test_receipt.py
git commit -m "feat: add rollback_data field to ActionResult"
```

---

## Cycle 2: Add `load_receipt()` to `receipt.py`

**Files:**
- Modify: `enact/receipt.py`
- Modify: `tests/test_receipt.py`

### Step 1: Write the failing test

Add to `tests/test_receipt.py`:

```python
import os
import json
import tempfile
from enact.receipt import build_receipt, sign_receipt, write_receipt, load_receipt
from enact.models import Receipt

def test_load_receipt_roundtrip(tmp_path):
    """Receipt written to disk can be loaded back and matches original."""
    receipt = build_receipt(
        workflow="test_workflow",
        actor_email="agent@test.com",
        payload={"key": "val"},
        policy_results=[],
        decision="PASS",
    )
    receipt = sign_receipt(receipt, "test-secret")
    write_receipt(receipt, str(tmp_path))

    loaded = load_receipt(receipt.run_id, str(tmp_path))

    assert loaded.run_id == receipt.run_id
    assert loaded.workflow == receipt.workflow
    assert loaded.signature == receipt.signature

def test_load_receipt_raises_for_missing_run_id(tmp_path):
    with pytest.raises(FileNotFoundError, match="No receipt found for run_id"):
        load_receipt("nonexistent-uuid", str(tmp_path))
```

### Step 2: Run to verify fails

```bash
pytest tests/test_receipt.py::test_load_receipt_roundtrip -v
```
Expected: `ImportError` — `load_receipt` not exported yet.

### Step 3: Add `load_receipt()` to `enact/receipt.py`

At the end of `enact/receipt.py`, after `write_receipt()`:

```python
def load_receipt(run_id: str, directory: str = "receipts") -> Receipt:
    """
    Load a previously written receipt from disk by its run_id.

    Args:
        run_id    — the UUID run_id used as the filename (without .json extension)
        directory — directory to read from (must match the directory used in write_receipt)

    Returns:
        Receipt — validated Pydantic model

    Raises:
        FileNotFoundError — if no receipt file exists for the given run_id
    """
    filepath = os.path.join(directory, f"{run_id}.json")
    if not os.path.exists(filepath):
        raise FileNotFoundError(f"No receipt found for run_id: {run_id}")
    with open(filepath) as f:
        return Receipt.model_validate(json.load(f))
```

### Step 4: Run tests

```bash
pytest tests/test_receipt.py -v
```
Expected: all pass.

### Step 5: Commit

```bash
git add enact/receipt.py tests/test_receipt.py
git commit -m "feat: add load_receipt() to receipt.py"
```

---

## Cycle 3: Add `close_pr`, `close_issue`, `create_branch_from_sha` to GitHubConnector

**Files:**
- Modify: `enact/connectors/github.py`
- Modify: `tests/test_github.py`

### Step 1: Write the failing tests

Add to `tests/test_github.py`:

```python
class TestClosePr:
    def test_close_pr_success(self, connector):
        mock_repo = MagicMock()
        mock_pr = MagicMock()
        mock_pr.state = "open"
        mock_repo.get_pull.return_value = mock_pr
        connector._get_repo = MagicMock(return_value=mock_repo)

        result = connector.close_pr(repo="owner/repo", pr_number=42)

        assert result.success is True
        assert result.action == "close_pr"
        assert result.output["pr_number"] == 42
        assert result.output["already_done"] is False
        mock_pr.edit.assert_called_once_with(state="closed")

    def test_close_pr_already_closed(self, connector):
        mock_repo = MagicMock()
        mock_pr = MagicMock()
        mock_pr.state = "closed"
        mock_repo.get_pull.return_value = mock_pr
        connector._get_repo = MagicMock(return_value=mock_repo)

        result = connector.close_pr(repo="owner/repo", pr_number=42)

        assert result.success is True
        assert result.output["already_done"] == "closed"
        mock_pr.edit.assert_not_called()

    def test_close_pr_failure(self, connector):
        connector._get_repo = MagicMock(side_effect=Exception("API error"))
        result = connector.close_pr(repo="owner/repo", pr_number=42)
        assert result.success is False
        assert "API error" in result.output["error"]

    def test_close_pr_not_in_default_allowlist(self):
        """close_pr is a rollback operation — must be explicitly allowed."""
        with patch("enact.connectors.github.Github"):
            conn = GitHubConnector(token="fake")
        # close_pr is NOT in the default allowlist (it's a rollback-only operation)
        assert "close_pr" not in conn._allowed_actions

    def test_close_pr_blocked_without_allowlist(self, connector):
        with patch("enact.connectors.github.Github"):
            conn = GitHubConnector(token="fake", allowed_actions=["create_pr"])
        with pytest.raises(PermissionError, match="not in allowlist"):
            conn.close_pr(repo="owner/repo", pr_number=1)


class TestCloseIssue:
    def test_close_issue_success(self, connector):
        mock_repo = MagicMock()
        mock_issue = MagicMock()
        mock_issue.state = "open"
        mock_repo.get_issue.return_value = mock_issue
        connector._get_repo = MagicMock(return_value=mock_repo)

        result = connector.close_issue(repo="owner/repo", issue_number=7)

        assert result.success is True
        assert result.action == "close_issue"
        assert result.output["issue_number"] == 7
        assert result.output["already_done"] is False
        mock_issue.edit.assert_called_once_with(state="closed")

    def test_close_issue_already_closed(self, connector):
        mock_repo = MagicMock()
        mock_issue = MagicMock()
        mock_issue.state = "closed"
        mock_repo.get_issue.return_value = mock_issue
        connector._get_repo = MagicMock(return_value=mock_repo)

        result = connector.close_issue(repo="owner/repo", issue_number=7)

        assert result.success is True
        assert result.output["already_done"] == "closed"

    def test_close_issue_failure(self, connector):
        connector._get_repo = MagicMock(side_effect=Exception("not found"))
        result = connector.close_issue(repo="owner/repo", issue_number=7)
        assert result.success is False
        assert "not found" in result.output["error"]


class TestCreateBranchFromSha:
    def test_create_branch_from_sha_success(self, connector):
        mock_repo = MagicMock()
        mock_repo.get_branch.side_effect = Exception("not found")  # doesn't exist yet
        connector._get_repo = MagicMock(return_value=mock_repo)

        result = connector.create_branch_from_sha(
            repo="owner/repo", branch="agent/restored", sha="deadbeef"
        )

        assert result.success is True
        assert result.action == "create_branch_from_sha"
        assert result.output["branch"] == "agent/restored"
        assert result.output["already_done"] is False
        mock_repo.create_git_ref.assert_called_once_with(
            "refs/heads/agent/restored", "deadbeef"
        )

    def test_create_branch_from_sha_already_exists(self, connector):
        mock_repo = MagicMock()
        mock_repo.get_branch.return_value = MagicMock()  # branch exists
        connector._get_repo = MagicMock(return_value=mock_repo)

        result = connector.create_branch_from_sha(
            repo="owner/repo", branch="agent/restored", sha="deadbeef"
        )

        assert result.success is True
        assert result.output["already_done"] == "created"

    def test_create_branch_from_sha_failure(self, connector):
        connector._get_repo = MagicMock(side_effect=Exception("API error"))
        result = connector.create_branch_from_sha(
            repo="owner/repo", branch="agent/x", sha="abc"
        )
        assert result.success is False
        assert "API error" in result.output["error"]
```

### Step 2: Run to verify fails

```bash
pytest tests/test_github.py::TestClosePr -v
```
Expected: `AttributeError` — methods don't exist yet.

### Step 3: Add the three methods to `enact/connectors/github.py`

Update the `__init__` default allowlist — `close_pr`, `close_issue`, `create_branch_from_sha` are **NOT** in the default list (rollback-only operations, require explicit opt-in):

```python
self._allowed_actions = set(
    allowed_actions
    or [
        "create_branch",
        "create_pr",
        "push_commit",
        "delete_branch",
        "create_issue",
        "merge_pr",
        # close_pr, close_issue, create_branch_from_sha are rollback operations
        # — not included by default; must be explicitly added to allowed_actions
    ]
)
```

Add after `merge_pr()`:

```python
    def close_pr(self, repo: str, pr_number: int) -> ActionResult:
        """
        Close an open pull request without merging.
        Used as the rollback inverse of create_pr.

        Args:
            repo      — "owner/repo" string
            pr_number — integer PR number

        Returns:
            ActionResult — success=True with {"pr_number": int}, or
                           success=False with {"error": str(e)}
        """
        self._check_allowed("close_pr")
        try:
            repo_obj = self._get_repo(repo)
            pr = repo_obj.get_pull(pr_number)
            if pr.state == "closed":
                return ActionResult(
                    action="close_pr",
                    system="github",
                    success=True,
                    output={"pr_number": pr_number, "already_done": "closed"},
                )
            pr.edit(state="closed")
            return ActionResult(
                action="close_pr",
                system="github",
                success=True,
                output={"pr_number": pr_number, "already_done": False},
            )
        except Exception as e:
            return ActionResult(
                action="close_pr",
                system="github",
                success=False,
                output={"error": str(e)},
            )

    def close_issue(self, repo: str, issue_number: int) -> ActionResult:
        """
        Close an open issue.
        Used as the rollback inverse of create_issue.

        Args:
            repo         — "owner/repo" string
            issue_number — integer issue number

        Returns:
            ActionResult — success=True with {"issue_number": int}, or
                           success=False with {"error": str(e)}
        """
        self._check_allowed("close_issue")
        try:
            repo_obj = self._get_repo(repo)
            issue = repo_obj.get_issue(issue_number)
            if issue.state == "closed":
                return ActionResult(
                    action="close_issue",
                    system="github",
                    success=True,
                    output={"issue_number": issue_number, "already_done": "closed"},
                )
            issue.edit(state="closed")
            return ActionResult(
                action="close_issue",
                system="github",
                success=True,
                output={"issue_number": issue_number, "already_done": False},
            )
        except Exception as e:
            return ActionResult(
                action="close_issue",
                system="github",
                success=False,
                output={"error": str(e)},
            )

    def create_branch_from_sha(self, repo: str, branch: str, sha: str) -> ActionResult:
        """
        Create a branch pointing at a specific commit SHA.
        Used as the rollback inverse of delete_branch — restores a deleted branch
        to the SHA captured before deletion.

        Args:
            repo   — "owner/repo" string
            branch — branch name to restore
            sha    — commit SHA to point the new branch at

        Returns:
            ActionResult — success=True with {"branch": branch}, or
                           success=False with {"error": str(e)}
        """
        self._check_allowed("create_branch_from_sha")
        try:
            repo_obj = self._get_repo(repo)
            try:
                repo_obj.get_branch(branch)
                return ActionResult(
                    action="create_branch_from_sha",
                    system="github",
                    success=True,
                    output={"branch": branch, "already_done": "created"},
                )
            except Exception:
                pass  # Branch doesn't exist — proceed to create
            repo_obj.create_git_ref(f"refs/heads/{branch}", sha)
            return ActionResult(
                action="create_branch_from_sha",
                system="github",
                success=True,
                output={"branch": branch, "already_done": False},
            )
        except Exception as e:
            return ActionResult(
                action="create_branch_from_sha",
                system="github",
                success=False,
                output={"error": str(e)},
            )
```

### Step 4: Run tests

```bash
pytest tests/test_github.py -v
```
Expected: all pass (including new TestClosePr, TestCloseIssue, TestCreateBranchFromSha).

### Step 5: Commit

```bash
git add enact/connectors/github.py tests/test_github.py
git commit -m "feat: add close_pr, close_issue, create_branch_from_sha to GitHubConnector"
```

---

## Cycle 4: Populate `rollback_data` in existing GitHub connector methods

**Files:**
- Modify: `enact/connectors/github.py`
- Modify: `tests/test_github.py`

The goal: every successful non-noop action now includes `rollback_data` so the receipt is a complete undo blueprint.

### Step 1: Add rollback_data assertions to existing tests in `tests/test_github.py`

Add these assertions to the **existing** success test in each class:

In `TestCreateBranch::test_create_branch_success`, add:
```python
assert result.rollback_data == {"repo": "owner/repo", "branch": "agent/feature-x"}
```

In `TestCreateBranchIdempotency::test_create_branch_returns_success_when_already_exists`, add:
```python
assert result.rollback_data == {}  # already_done — we didn't create it, don't delete it
```

In `TestCreatePr` success test, add:
```python
assert result.rollback_data["pr_number"] == mock_pr.number
assert result.rollback_data["repo"] == "owner/repo"
```

In `TestCreateIssue` success test, add:
```python
assert result.rollback_data["issue_number"] == mock_issue.number
assert result.rollback_data["repo"] == "owner/repo"
```

In `TestDeleteBranch` success test (non-idempotent path), add:
```python
assert result.rollback_data["branch"] == "agent/feature-x"
assert result.rollback_data["sha"] == mock_ref.object.sha
assert result.rollback_data["repo"] == "owner/repo"
```

In `TestDeleteBranch` idempotent test (already deleted), add:
```python
assert result.rollback_data == {}  # Branch wasn't there — nothing to restore
```

In `TestMergePr` success test, add:
```python
assert result.rollback_data == {}  # merge_pr is irreversible
```

### Step 2: Run to verify fails

```bash
pytest tests/test_github.py -v
```
Expected: assertion failures on `rollback_data` in multiple tests.

### Step 3: Update existing methods in `enact/connectors/github.py` to populate `rollback_data`

**`create_branch` — fresh action return** (line ~136-142):
```python
return ActionResult(
    action="create_branch",
    system="github",
    success=True,
    output={"branch": branch, "already_done": False},
    rollback_data={"repo": repo, "branch": branch},
)
```

**`create_branch` — already_done return** (line ~126-131):
```python
return ActionResult(
    action="create_branch",
    system="github",
    success=True,
    output={"branch": branch, "already_done": "created"},
    rollback_data={},
)
```

**`create_pr` — fresh action return** (line ~185-190):
```python
return ActionResult(
    action="create_pr",
    system="github",
    success=True,
    output={"pr_number": pr.number, "url": pr.html_url, "already_done": False},
    rollback_data={"repo": repo, "pr_number": pr.number},
)
```

**`create_pr` — already_done return** (line ~176-181):
```python
return ActionResult(
    action="create_pr",
    system="github",
    success=True,
    output={"pr_number": pr.number, "url": pr.html_url, "already_done": "created"},
    rollback_data={},
)
```

**`create_issue` — fresh action return** (line ~229-234):
```python
return ActionResult(
    action="create_issue",
    system="github",
    success=True,
    output={"issue_number": issue.number, "url": issue.html_url, "already_done": False},
    rollback_data={"repo": repo, "issue_number": issue.number},
)
```

**`create_issue` — already_done return**:
```python
rollback_data={},
```

**`delete_branch` — fresh action (after `ref.delete()`):**

First, capture SHA before deleting. Find the line `ref = repo_obj.get_git_ref(f"heads/{branch}")` — AFTER this line but BEFORE `ref.delete()`, the ref object has `.object.sha`. Update the fresh-action return to:
```python
sha = ref.object.sha  # capture before deletion for potential rollback
ref.delete()
return ActionResult(
    action="delete_branch",
    system="github",
    success=True,
    output={"branch": branch, "already_done": False},
    rollback_data={"repo": repo, "branch": branch, "sha": sha},
)
```

**`delete_branch` — already_done return** (UnknownObjectException path):
```python
return ActionResult(
    action="delete_branch",
    system="github",
    success=True,
    output={"branch": branch, "already_done": "deleted"},
    rollback_data={},
)
```

**`merge_pr` — fresh action return**:
```python
return ActionResult(
    action="merge_pr",
    system="github",
    success=True,
    output={"merged": result.merged, "sha": result.sha, "already_done": False},
    rollback_data={},  # merge_pr is irreversible — no undo possible
)
```

### Step 4: Run tests

```bash
pytest tests/test_github.py -v
```
Expected: all pass.

### Step 5: Commit

```bash
git add enact/connectors/github.py tests/test_github.py
git commit -m "feat: populate rollback_data in GitHub connector methods"
```

---

## Cycle 5: Populate `rollback_data` in Postgres connector

**Files:**
- Modify: `enact/connectors/postgres.py`
- Modify: `tests/test_postgres.py`

### Step 1: Update existing Postgres tests with proper mock data and rollback_data assertions

**`update_row` — replace `test_returns_rows_updated_count_with_already_done_false`:**

The existing mock `make_cursor(rowcount=1)` defaults `fetchall=[]` and `description=[]`. After the pre-SELECT change, `old_rows` would be `[]`. The test would pass vacuously — the key exists but captures nothing useful. Replace with:

```python
def test_returns_rows_updated_count_with_already_done_false(self):
    # Pre-SELECT sees the old row; UPDATE affects 1 row.
    # Same cursor handles both: fetchall() returns old data, rowcount is used post-UPDATE.
    cursor = make_cursor(
        rows=[(1, "old@acme.com")],
        description=[("id",), ("email",)],
        rowcount=1,
    )
    conn = make_conn(cursor)
    pg = make_pg(conn=conn)

    result = pg.update_row("users", data={"email": "new@acme.com"}, where={"id": 1})

    assert result.success is True
    assert result.action == "update_row"
    assert result.system == "postgres"
    assert result.output["rows_updated"] == 1
    assert result.output["already_done"] is False
    assert result.rollback_data["table"] == "users"
    assert result.rollback_data["old_rows"] == [{"id": 1, "email": "old@acme.com"}]
    assert result.rollback_data["where"] == {"id": 1}
    conn.commit.assert_called_once()
```

**`delete_row` — replace `test_deletes_existing_row_returns_already_done_false`:**

Same problem: `make_cursor(rowcount=1)` gives `fetchall=[]`, so `deleted_rows=[]`. Worse: a subsequent `rollback()` on a receipt with `deleted_rows=[]` would silently skip re-insertion (treating it as "no rows were deleted"). Replace with:

```python
def test_deletes_existing_row_returns_already_done_false(self):
    # Pre-SELECT captures the row before deletion for rollback.
    cursor = make_cursor(
        rows=[(1, "jane@acme.com")],
        description=[("id",), ("email",)],
        rowcount=1,
    )
    conn = make_conn(cursor)
    pg = make_pg(conn=conn)

    result = pg.delete_row("users", where={"id": 1})

    assert result.success is True
    assert result.action == "delete_row"
    assert result.system == "postgres"
    assert result.output["rows_deleted"] == 1
    assert result.output["already_done"] is False
    assert result.rollback_data["table"] == "users"
    assert result.rollback_data["deleted_rows"] == [{"id": 1, "email": "jane@acme.com"}]
    conn.commit.assert_called_once()
```

**`delete_row` — also update `test_deletes_multiple_rows_returns_already_done_false`:**

```python
def test_deletes_multiple_rows_returns_already_done_false(self):
    cursor = make_cursor(
        rows=[(1, "a@b.com"), (2, "c@d.com"), (3, "e@f.com")],
        description=[("id",), ("email",)],
        rowcount=3,
    )
    conn = make_conn(cursor)
    pg = make_pg(conn=conn)

    result = pg.delete_row("logs", where={"user_id": 5})

    assert result.success is True
    assert result.output["rows_deleted"] == 3
    assert result.output["already_done"] is False
    assert len(result.rollback_data["deleted_rows"]) == 3
```

**`delete_row` — also update `test_zero_rows_deleted_returns_already_done_deleted`:**

```python
def test_zero_rows_deleted_returns_already_done_deleted(self):
    cursor = make_cursor(rows=[], description=[("id",)], rowcount=0)
    conn = make_conn(cursor)
    pg = make_pg(conn=conn)

    result = pg.delete_row("users", where={"id": 999})

    assert result.success is True
    assert result.output["rows_deleted"] == 0
    assert result.output["already_done"] == "deleted"
    assert result.rollback_data["deleted_rows"] == []  # Nothing to restore — expected
```

**`insert_row` — add to `test_returns_inserted_row_data_with_already_done_false`:**

```python
assert result.rollback_data["table"] == "users"
assert result.rollback_data["inserted_row"] == {"id": 42, "email": "jane@acme.com", "name": "Jane"}
```

### Step 2: Run to verify fails

```bash
pytest tests/test_postgres.py -v
```
Expected: assertion failures on `rollback_data`.

### Step 3: Update `insert_row` in `enact/connectors/postgres.py`

In `insert_row`, after `row_dict = dict(zip(cols, row)) if row else {}`, update the return:
```python
return ActionResult(
    action="insert_row",
    system="postgres",
    success=True,
    output={**row_dict, "already_done": False},
    rollback_data={"table": table, "inserted_row": row_dict},
)
```

### Step 4: Update `update_row` in `enact/connectors/postgres.py`

Add a pre-SELECT before the UPDATE, inside the `with conn.cursor() as cursor:` block. The full updated `update_row` method:

```python
def update_row(self, table: str, data: dict, where: dict) -> ActionResult:
    self._check_allowed("update_row")
    conn = None
    try:
        conn = self._get_connection()
        with conn.cursor() as cursor:
            # --- Pre-SELECT: capture current state for rollback ---
            where_clause = pgsql.SQL(" AND ").join(
                pgsql.SQL("{} = {}").format(
                    pgsql.Identifier(k), pgsql.Placeholder()
                )
                for k in where
            )
            pre_query = pgsql.SQL("SELECT * FROM {} WHERE {}").format(
                pgsql.Identifier(table), where_clause
            )
            cursor.execute(pre_query, list(where.values()))
            old_rows_raw = cursor.fetchall()
            old_cols = [desc[0] for desc in (cursor.description or [])]
            old_rows = [dict(zip(old_cols, row)) for row in old_rows_raw]
            # --- UPDATE ---
            set_clause = pgsql.SQL(", ").join(
                pgsql.SQL("{} = {}").format(
                    pgsql.Identifier(k), pgsql.Placeholder()
                )
                for k in data
            )
            query = pgsql.SQL("UPDATE {} SET {} WHERE {}").format(
                pgsql.Identifier(table), set_clause, where_clause
            )
            cursor.execute(query, list(data.values()) + list(where.values()))
            conn.commit()
            return ActionResult(
                action="update_row",
                system="postgres",
                success=True,
                output={"rows_updated": cursor.rowcount, "already_done": False},
                rollback_data={"table": table, "old_rows": old_rows, "where": where},
            )
    except Exception as e:
        if conn:
            conn.rollback()
        return ActionResult(
            action="update_row",
            system="postgres",
            success=False,
            output={"error": str(e)},
        )
```

### Step 5: Update `delete_row` in `enact/connectors/postgres.py`

Add pre-SELECT before the DELETE. Full updated `delete_row`:

```python
def delete_row(self, table: str, where: dict) -> ActionResult:
    self._check_allowed("delete_row")
    conn = None
    try:
        conn = self._get_connection()
        with conn.cursor() as cursor:
            where_clause = pgsql.SQL(" AND ").join(
                pgsql.SQL("{} = {}").format(
                    pgsql.Identifier(k), pgsql.Placeholder()
                )
                for k in where
            )
            # --- Pre-SELECT: capture rows before deleting for rollback ---
            pre_query = pgsql.SQL("SELECT * FROM {} WHERE {}").format(
                pgsql.Identifier(table), where_clause
            )
            cursor.execute(pre_query, list(where.values()))
            rows_raw = cursor.fetchall()
            cols = [desc[0] for desc in (cursor.description or [])]
            deleted_rows = [dict(zip(cols, row)) for row in rows_raw]
            # --- DELETE ---
            query = pgsql.SQL("DELETE FROM {} WHERE {}").format(
                pgsql.Identifier(table), where_clause
            )
            cursor.execute(query, list(where.values()))
            conn.commit()
            rows_deleted = cursor.rowcount
            return ActionResult(
                action="delete_row",
                system="postgres",
                success=True,
                output={
                    "rows_deleted": rows_deleted,
                    "already_done": "deleted" if rows_deleted == 0 else False,
                },
                rollback_data={"table": table, "deleted_rows": deleted_rows},
            )
    except Exception as e:
        if conn:
            conn.rollback()
        return ActionResult(
            action="delete_row",
            system="postgres",
            success=False,
            output={"error": str(e)},
        )
```

### Step 6: Run tests

```bash
pytest tests/test_postgres.py -v
```
Expected: all pass. The mock cursor in existing tests will need `.description` set — check that existing mocks already have it. If not, add `cursor.description = [("id",), ("name",)]` to existing fixtures.

### Step 7: Commit

```bash
git add enact/connectors/postgres.py tests/test_postgres.py
git commit -m "feat: populate rollback_data in Postgres connector methods"
```

---

## Cycle 6: Create `enact/rollback.py`

**Files:**
- Create: `enact/rollback.py`
- Create: `tests/test_rollback.py` (first batch of tests)

### Step 1: Write the failing tests

Create `tests/test_rollback.py`:

```python
"""
Tests for enact/rollback.py — execute_rollback_action() dispatch logic.
All connector calls are mocked. No real GitHub/Postgres API calls made.
"""
import pytest
from unittest.mock import MagicMock
from enact.models import ActionResult
from enact.rollback import execute_rollback_action


# ── GitHub rollback dispatch ──────────────────────────────────────────────────

class TestRollbackGitHub:
    def _make_gh_connector(self):
        connector = MagicMock()
        connector.delete_branch.return_value = ActionResult(
            action="delete_branch", system="github", success=True,
            output={"branch": "agent/x", "already_done": False},
        )
        connector.close_pr.return_value = ActionResult(
            action="close_pr", system="github", success=True,
            output={"pr_number": 42, "already_done": False},
        )
        connector.close_issue.return_value = ActionResult(
            action="close_issue", system="github", success=True,
            output={"issue_number": 7, "already_done": False},
        )
        connector.create_branch_from_sha.return_value = ActionResult(
            action="create_branch_from_sha", system="github", success=True,
            output={"branch": "agent/x", "already_done": False},
        )
        return connector

    def test_rollback_create_branch_calls_delete_branch(self):
        connector = self._make_gh_connector()
        systems = {"github": connector}
        action = ActionResult(
            action="create_branch", system="github", success=True,
            output={"branch": "agent/x", "already_done": False},
            rollback_data={"repo": "owner/repo", "branch": "agent/x"},
        )
        result = execute_rollback_action(action, systems)
        connector.delete_branch.assert_called_once_with(repo="owner/repo", branch="agent/x")
        assert result.success is True

    def test_rollback_create_pr_calls_close_pr(self):
        connector = self._make_gh_connector()
        systems = {"github": connector}
        action = ActionResult(
            action="create_pr", system="github", success=True,
            output={"pr_number": 42, "already_done": False},
            rollback_data={"repo": "owner/repo", "pr_number": 42},
        )
        result = execute_rollback_action(action, systems)
        connector.close_pr.assert_called_once_with(repo="owner/repo", pr_number=42)
        assert result.success is True

    def test_rollback_create_issue_calls_close_issue(self):
        connector = self._make_gh_connector()
        systems = {"github": connector}
        action = ActionResult(
            action="create_issue", system="github", success=True,
            output={"issue_number": 7, "already_done": False},
            rollback_data={"repo": "owner/repo", "issue_number": 7},
        )
        result = execute_rollback_action(action, systems)
        connector.close_issue.assert_called_once_with(repo="owner/repo", issue_number=7)
        assert result.success is True

    def test_rollback_delete_branch_calls_create_branch_from_sha(self):
        connector = self._make_gh_connector()
        systems = {"github": connector}
        action = ActionResult(
            action="delete_branch", system="github", success=True,
            output={"branch": "agent/x", "already_done": False},
            rollback_data={"repo": "owner/repo", "branch": "agent/x", "sha": "deadbeef"},
        )
        result = execute_rollback_action(action, systems)
        connector.create_branch_from_sha.assert_called_once_with(
            repo="owner/repo", branch="agent/x", sha="deadbeef"
        )
        assert result.success is True

    def test_rollback_merge_pr_is_irreversible(self):
        systems = {"github": MagicMock()}
        action = ActionResult(
            action="merge_pr", system="github", success=True,
            output={"merged": True, "already_done": False},
            rollback_data={},
        )
        result = execute_rollback_action(action, systems)
        assert result.success is False
        assert "cannot be reversed" in result.output["error"]

    def test_rollback_push_commit_is_irreversible(self):
        """push_commit cannot be undone — un-pushing requires destructive force-push."""
        systems = {"github": MagicMock()}
        action = ActionResult(
            action="push_commit", system="github", success=True,
            output={"sha": "deadbeef", "already_done": False},
            rollback_data={},
        )
        result = execute_rollback_action(action, systems)
        assert result.success is False
        assert "cannot be reversed" in result.output["error"]


# ── Postgres rollback dispatch ────────────────────────────────────────────────

class TestRollbackPostgres:
    def _make_pg_connector(self):
        connector = MagicMock()
        connector.delete_row.return_value = ActionResult(
            action="delete_row", system="postgres", success=True,
            output={"rows_deleted": 1, "already_done": False},
        )
        connector.update_row.return_value = ActionResult(
            action="update_row", system="postgres", success=True,
            output={"rows_updated": 1, "already_done": False},
        )
        connector.insert_row.return_value = ActionResult(
            action="insert_row", system="postgres", success=True,
            output={"id": 1, "already_done": False},
        )
        return connector

    def test_rollback_insert_row_calls_delete_row(self):
        connector = self._make_pg_connector()
        systems = {"postgres": connector}
        action = ActionResult(
            action="insert_row", system="postgres", success=True,
            output={"id": 1, "name": "jane", "already_done": False},
            rollback_data={"table": "users", "inserted_row": {"id": 1, "name": "jane"}},
        )
        result = execute_rollback_action(action, systems)
        # Should delete using "id" as the PK column
        connector.delete_row.assert_called_once_with(table="users", where={"id": 1})
        assert result.success is True

    def test_rollback_insert_row_uses_first_col_if_no_id(self):
        connector = self._make_pg_connector()
        systems = {"postgres": connector}
        action = ActionResult(
            action="insert_row", system="postgres", success=True,
            output={"email": "jane@co.com", "already_done": False},
            rollback_data={"table": "contacts", "inserted_row": {"email": "jane@co.com", "name": "jane"}},
        )
        execute_rollback_action(action, systems)
        connector.delete_row.assert_called_once_with(table="contacts", where={"email": "jane@co.com"})

    def test_rollback_update_row_reapplies_old_values(self):
        connector = self._make_pg_connector()
        systems = {"postgres": connector}
        action = ActionResult(
            action="update_row", system="postgres", success=True,
            output={"rows_updated": 1, "already_done": False},
            rollback_data={
                "table": "users",
                "old_rows": [{"id": 1, "name": "old_name"}],
                "where": {"id": 1},
            },
        )
        execute_rollback_action(action, systems)
        connector.update_row.assert_called_once_with(
            table="users",
            data={"id": 1, "name": "old_name"},
            where={"id": 1},
        )

    def test_rollback_update_row_skips_if_no_old_rows(self):
        connector = self._make_pg_connector()
        systems = {"postgres": connector}
        action = ActionResult(
            action="update_row", system="postgres", success=True,
            output={"rows_updated": 0, "already_done": False},
            rollback_data={"table": "users", "old_rows": [], "where": {"id": 999}},
        )
        result = execute_rollback_action(action, systems)
        connector.update_row.assert_not_called()
        assert result.success is True
        assert result.output.get("already_done") == "skipped"

    def test_rollback_delete_row_reinserts_deleted_rows(self):
        connector = self._make_pg_connector()
        systems = {"postgres": connector}
        action = ActionResult(
            action="delete_row", system="postgres", success=True,
            output={"rows_deleted": 1, "already_done": False},
            rollback_data={
                "table": "users",
                "deleted_rows": [{"id": 1, "name": "jane"}],
            },
        )
        execute_rollback_action(action, systems)
        connector.insert_row.assert_called_once_with(
            table="users", data={"id": 1, "name": "jane"}
        )

    def test_rollback_select_rows_is_skipped(self):
        connector = self._make_pg_connector()
        systems = {"postgres": connector}
        action = ActionResult(
            action="select_rows", system="postgres", success=True,
            output={"rows": []},
            rollback_data={},
        )
        result = execute_rollback_action(action, systems)
        connector.select_rows.assert_not_called()
        assert result.success is True
        assert result.output.get("already_done") == "skipped"


# ── System not found ──────────────────────────────────────────────────────────

class TestRollbackSystemNotFound:
    def test_missing_system_returns_failure(self):
        action = ActionResult(
            action="create_branch", system="github", success=True,
            output={}, rollback_data={"repo": "r", "branch": "b"},
        )
        result = execute_rollback_action(action, systems={})  # github not in systems
        assert result.success is False
        assert "not available for rollback" in result.output["error"]
```

### Step 2: Run to verify fails

```bash
pytest tests/test_rollback.py -v
```
Expected: `ImportError` — `enact.rollback` doesn't exist yet.

### Step 3: Create `enact/rollback.py`

```python
"""
Rollback execution logic for EnactClient.rollback().

execute_rollback_action() takes a single ActionResult and the systems dict,
and dispatches to the appropriate connector inverse method using rollback_data.

Inverse map:
    github.create_branch     -> github.delete_branch
    github.delete_branch     -> github.create_branch_from_sha
    github.create_pr         -> github.close_pr
    github.create_issue      -> github.close_issue
    github.merge_pr          -> (irreversible — cannot unmerge)
    github.push_commit       -> (irreversible — cannot un-push without destructive force)
    postgres.insert_row      -> postgres.delete_row  (using id or first col as PK)
    postgres.update_row      -> postgres.update_row  (with old_rows from rollback_data)
    postgres.delete_row      -> postgres.insert_row  (for each deleted row)
    postgres.select_rows     -> (read-only, skipped)
"""
from enact.models import ActionResult

# Actions that cannot be reversed — rollback returns a recorded failure.
# These are NOT errors — they are documented contracts. The rollback receipt
# records success=False for each so the caller knows what needs manual cleanup.
_IRREVERSIBLE = {
    ("github", "merge_pr"),     # Can't unmerge a merged PR
    ("github", "push_commit"),  # Can't un-push without destructive force-push
    # NOTE: Add future irreversible actions here (email sends, Slack messages, etc.)
    # Pattern: ("system_name", "action_name")
}

# Read-only actions — nothing to undo, rollback skips them gracefully
_READ_ONLY = {
    ("postgres", "select_rows"),
}


def execute_rollback_action(action_result: ActionResult, systems: dict) -> ActionResult:
    """
    Reverse a single action using its rollback_data.

    Args:
        action_result — the original ActionResult from the run receipt
        systems       — dict of connector instances (same as EnactClient._systems)

    Returns:
        ActionResult describing the rollback attempt:
          - success=True if the inverse operation succeeded
          - success=True, already_done="skipped" for read-only actions
          - success=False, output["error"] for irreversible or failed rollbacks
    """
    key = (action_result.system, action_result.action)

    if key in _READ_ONLY:
        return ActionResult(
            action=f"rollback_{action_result.action}",
            system=action_result.system,
            success=True,
            output={"already_done": "skipped", "reason": "read-only action"},
        )

    if key in _IRREVERSIBLE:
        return ActionResult(
            action=f"rollback_{action_result.action}",
            system=action_result.system,
            success=False,
            output={"error": f"{action_result.action} cannot be reversed"},
        )

    connector = systems.get(action_result.system)
    if connector is None:
        return ActionResult(
            action=f"rollback_{action_result.action}",
            system=action_result.system,
            success=False,
            output={"error": f"System '{action_result.system}' not available for rollback"},
        )

    rd = action_result.rollback_data

    if action_result.system == "github":
        return _rollback_github(action_result.action, rd, connector)
    elif action_result.system == "postgres":
        return _rollback_postgres(action_result.action, rd, connector)
    else:
        return ActionResult(
            action=f"rollback_{action_result.action}",
            system=action_result.system,
            success=False,
            output={"error": f"No rollback handler for system '{action_result.system}'"},
        )


def _rollback_github(action: str, rd: dict, connector) -> ActionResult:
    try:
        if action == "create_branch":
            return connector.delete_branch(repo=rd["repo"], branch=rd["branch"])
        elif action == "delete_branch":
            return connector.create_branch_from_sha(
                repo=rd["repo"], branch=rd["branch"], sha=rd["sha"]
            )
        elif action == "create_pr":
            return connector.close_pr(repo=rd["repo"], pr_number=rd["pr_number"])
        elif action == "create_issue":
            return connector.close_issue(repo=rd["repo"], issue_number=rd["issue_number"])
        else:
            return ActionResult(
                action=f"rollback_{action}",
                system="github",
                success=False,
                output={"error": f"No rollback handler for github.{action}"},
            )
    except Exception as e:
        return ActionResult(
            action=f"rollback_{action}",
            system="github",
            success=False,
            output={"error": f"Rollback failed for github.{action}: {str(e)}"},
        )


def _rollback_postgres(action: str, rd: dict, connector) -> ActionResult:
    try:
        if action == "insert_row":
            inserted_row = rd["inserted_row"]
            # Use "id" as PK if present, otherwise fall back to first column
            pk_col = "id" if "id" in inserted_row else list(inserted_row.keys())[0]
            pk_val = inserted_row[pk_col]
            return connector.delete_row(table=rd["table"], where={pk_col: pk_val})

        elif action == "update_row":
            old_rows = rd.get("old_rows", [])
            if not old_rows:
                return ActionResult(
                    action="rollback_update_row",
                    system="postgres",
                    success=True,
                    output={"already_done": "skipped", "reason": "no rows matched original update"},
                )
            # Restore original values using the same WHERE clause
            return connector.update_row(
                table=rd["table"],
                data=old_rows[0],
                where=rd["where"],
            )

        elif action == "delete_row":
            deleted_rows = rd.get("deleted_rows", [])
            if not deleted_rows:
                return ActionResult(
                    action="rollback_delete_row",
                    system="postgres",
                    success=True,
                    output={"already_done": "skipped", "reason": "no rows were deleted"},
                )
            results = [
                connector.insert_row(table=rd["table"], data=row)
                for row in deleted_rows
            ]
            all_success = all(r.success for r in results)
            return ActionResult(
                action="rollback_delete_row",
                system="postgres",
                success=all_success,
                output={"rows_restored": sum(1 for r in results if r.success)},
            )

        else:
            return ActionResult(
                action=f"rollback_{action}",
                system="postgres",
                success=False,
                output={"error": f"No rollback handler for postgres.{action}"},
            )
    except Exception as e:
        return ActionResult(
            action=f"rollback_{action}",
            system="postgres",
            success=False,
            output={"error": f"Rollback failed for postgres.{action}: {str(e)}"},
        )
```

### Step 4: Run tests

```bash
pytest tests/test_rollback.py -v
```
Expected: all pass.

### Step 5: Commit

```bash
git add enact/rollback.py tests/test_rollback.py
git commit -m "feat: add execute_rollback_action() dispatch logic in rollback.py"
```

---

## Cycle 7: Add `rollback_enabled` + `rollback()` to `EnactClient`

**Files:**
- Modify: `enact/client.py`
- Modify: `tests/test_rollback.py` (add EnactClient.rollback tests)
- Modify: `tests/test_client.py` (verify rollback_enabled=False default)

### Step 1: Add failing tests to `tests/test_rollback.py`

Append to `tests/test_rollback.py`:

```python
# ── EnactClient.rollback() ────────────────────────────────────────────────────

import os
import json
import tempfile
import pytest
from unittest.mock import patch, MagicMock
from enact.client import EnactClient
from enact.models import ActionResult, Receipt, PolicyResult
from enact.receipt import build_receipt, sign_receipt, write_receipt


def _write_test_receipt(tmp_path, actions_taken, decision="PASS"):
    """Helper: write a receipt to tmp_path and return its run_id."""
    receipt = build_receipt(
        workflow="test_workflow",
        actor_email="agent@test.com",
        payload={"x": 1},
        policy_results=[PolicyResult(policy="p", passed=True, reason="ok")],
        decision=decision,
        actions_taken=actions_taken,
    )
    receipt = sign_receipt(receipt, "enact-default-secret")
    write_receipt(receipt, str(tmp_path))
    return receipt.run_id


class TestEnactClientRollbackGate:
    def test_rollback_disabled_by_default(self):
        client = EnactClient()
        with pytest.raises(PermissionError, match="premium feature"):
            client.rollback("any-run-id")

    def test_rollback_enabled_flag(self):
        client = EnactClient(rollback_enabled=True)
        assert client._rollback_enabled is True

    def test_rollback_missing_receipt_raises(self, tmp_path):
        client = EnactClient(rollback_enabled=True, receipt_dir=str(tmp_path))
        with pytest.raises(FileNotFoundError, match="No receipt found"):
            client.rollback("nonexistent-uuid")

    def test_rollback_blocked_run_raises(self, tmp_path):
        run_id = _write_test_receipt(tmp_path, actions_taken=[], decision="BLOCK")
        client = EnactClient(rollback_enabled=True, receipt_dir=str(tmp_path))
        with pytest.raises(ValueError, match="Cannot rollback a blocked run"):
            client.rollback(run_id)


class TestEnactClientRollbackExecution:
    def test_rollback_reverses_actions_in_reverse_order(self, tmp_path):
        """Actions are undone last-to-first."""
        actions = [
            ActionResult(
                action="create_branch", system="github", success=True,
                output={"branch": "agent/x", "already_done": False},
                rollback_data={"repo": "owner/repo", "branch": "agent/x"},
            ),
            ActionResult(
                action="create_pr", system="github", success=True,
                output={"pr_number": 1, "already_done": False},
                rollback_data={"repo": "owner/repo", "pr_number": 1},
            ),
        ]
        run_id = _write_test_receipt(tmp_path, actions)

        mock_gh = MagicMock()
        mock_gh.close_pr.return_value = ActionResult(
            action="close_pr", system="github", success=True, output={}
        )
        mock_gh.delete_branch.return_value = ActionResult(
            action="delete_branch", system="github", success=True, output={}
        )

        client = EnactClient(
            systems={"github": mock_gh},
            rollback_enabled=True,
            receipt_dir=str(tmp_path),
        )
        result, receipt = client.rollback(run_id)

        # Verify order: PR closed first (it was last), then branch deleted
        call_order = [call[0] for call in mock_gh.method_calls]
        assert call_order.index("close_pr") < call_order.index("delete_branch")

    def test_rollback_skips_already_done_noops(self, tmp_path):
        """Actions with already_done set were not actually performed — skip them."""
        actions = [
            ActionResult(
                action="create_branch", system="github", success=True,
                output={"branch": "agent/x", "already_done": "created"},
                rollback_data={},
            ),
        ]
        run_id = _write_test_receipt(tmp_path, actions)

        mock_gh = MagicMock()
        client = EnactClient(
            systems={"github": mock_gh},
            rollback_enabled=True,
            receipt_dir=str(tmp_path),
        )
        result, receipt = client.rollback(run_id)

        mock_gh.delete_branch.assert_not_called()

    def test_rollback_skips_failed_actions(self, tmp_path):
        """Failed actions produced no state change — nothing to undo."""
        actions = [
            ActionResult(
                action="create_branch", system="github", success=False,
                output={"error": "API error"},
                rollback_data={},
            ),
        ]
        run_id = _write_test_receipt(tmp_path, actions)

        mock_gh = MagicMock()
        client = EnactClient(
            systems={"github": mock_gh},
            rollback_enabled=True,
            receipt_dir=str(tmp_path),
        )
        result, receipt = client.rollback(run_id)

        mock_gh.delete_branch.assert_not_called()

    def test_rollback_partial_failure_continues(self, tmp_path):
        """If one rollback step fails, the rest still execute."""
        actions = [
            ActionResult(
                action="create_branch", system="github", success=True,
                output={"branch": "agent/x", "already_done": False},
                rollback_data={"repo": "owner/repo", "branch": "agent/x"},
            ),
            ActionResult(
                action="create_pr", system="github", success=True,
                output={"pr_number": 1, "already_done": False},
                rollback_data={"repo": "owner/repo", "pr_number": 1},
            ),
        ]
        run_id = _write_test_receipt(tmp_path, actions)

        mock_gh = MagicMock()
        # close_pr fails, delete_branch should still be called
        mock_gh.close_pr.return_value = ActionResult(
            action="close_pr", system="github", success=False, output={"error": "API down"}
        )
        mock_gh.delete_branch.return_value = ActionResult(
            action="delete_branch", system="github", success=True, output={}
        )

        client = EnactClient(
            systems={"github": mock_gh},
            rollback_enabled=True,
            receipt_dir=str(tmp_path),
        )
        result, receipt = client.rollback(run_id)

        mock_gh.close_pr.assert_called_once()
        mock_gh.delete_branch.assert_called_once()
        assert result.success is False  # partial failure → RunResult.success=False
        assert receipt.decision == "PARTIAL"  # not "PASS" — caller must know undo was incomplete

    def test_rollback_produces_signed_receipt(self, tmp_path):
        actions = [
            ActionResult(
                action="create_branch", system="github", success=True,
                output={"branch": "agent/x", "already_done": False},
                rollback_data={"repo": "owner/repo", "branch": "agent/x"},
            ),
        ]
        run_id = _write_test_receipt(tmp_path, actions)

        mock_gh = MagicMock()
        mock_gh.delete_branch.return_value = ActionResult(
            action="delete_branch", system="github", success=True, output={}
        )
        client = EnactClient(
            systems={"github": mock_gh},
            rollback_enabled=True,
            receipt_dir=str(tmp_path),
        )
        result, receipt = client.rollback(run_id)

        assert receipt.signature != ""
        assert receipt.decision == "PASS"

    def test_rollback_receipt_references_original_run_id(self, tmp_path):
        actions = [
            ActionResult(
                action="create_branch", system="github", success=True,
                output={"branch": "agent/x", "already_done": False},
                rollback_data={"repo": "owner/repo", "branch": "agent/x"},
            ),
        ]
        run_id = _write_test_receipt(tmp_path, actions)

        mock_gh = MagicMock()
        mock_gh.delete_branch.return_value = ActionResult(
            action="delete_branch", system="github", success=True, output={}
        )
        client = EnactClient(
            systems={"github": mock_gh},
            rollback_enabled=True,
            receipt_dir=str(tmp_path),
        )
        _, receipt = client.rollback(run_id)

        assert receipt.payload["original_run_id"] == run_id
        assert receipt.payload["rollback"] is True
```

### Step 2: Run to verify fails

```bash
pytest tests/test_rollback.py::TestEnactClientRollbackGate -v
```
Expected: `TypeError` — `EnactClient.__init__` doesn't accept `rollback_enabled`.

### Step 3: Update `enact/client.py`

**In `__init__`:** Add `rollback_enabled` param and import:

```python
# At top of client.py, add:
from enact.receipt import build_receipt, sign_receipt, write_receipt, load_receipt
from enact.rollback import execute_rollback_action

# In __init__ signature, add:
    rollback_enabled: bool = False,

# In __init__ body, add:
    self._rollback_enabled = rollback_enabled
```

**Add `rollback()` method** at the end of the class:

```python
    def rollback(self, run_id: str) -> tuple[RunResult, Receipt]:
        """
        Reverse all successful actions from a previous run, in reverse order.

        Loads the receipt for run_id, filters to actions that were actually
        executed (success=True AND not already_done), then calls the inverse
        operation for each via execute_rollback_action(). Produces a new
        signed receipt referencing the original run.

        PREMIUM FEATURE: requires rollback_enabled=True at init time.

        Args:
            run_id — the UUID from the original run's Receipt.run_id

        Returns:
            tuple[RunResult, Receipt] — RunResult.success=False if any rollback
            step failed (best-effort: all steps are attempted regardless)

        Raises:
            PermissionError  — if rollback_enabled=False
            FileNotFoundError — if no receipt exists for run_id
            ValueError       — if the original run was a BLOCK (nothing to undo)
        """
        if not self._rollback_enabled:
            raise PermissionError(
                "Rollback is a premium feature. Set rollback_enabled=True on EnactClient to use it."
            )

        original_receipt = load_receipt(run_id, self._receipt_dir)

        if original_receipt.decision == "BLOCK":
            raise ValueError("Cannot rollback a blocked run — no actions were taken")

        # Filter to actions that were actually executed: success=True AND not a noop
        reversible = [
            a for a in reversed(original_receipt.actions_taken)
            if a.success and not a.output.get("already_done")
        ]

        # Best-effort: execute all rollbacks, collect results
        rollback_results = []
        for action in reversible:
            result = execute_rollback_action(action, self._systems)
            rollback_results.append(result)

        # Determine overall outcome BEFORE building the receipt — decision depends on it
        all_success = all(r.success for r in rollback_results) if rollback_results else True

        # Build + sign + write rollback receipt
        receipt = build_receipt(
            workflow=f"rollback:{original_receipt.workflow}",
            actor_email=original_receipt.actor_email,
            payload={"original_run_id": run_id, "rollback": True},
            policy_results=[],
            decision="PASS" if all_success else "PARTIAL",
            actions_taken=rollback_results,
        )
        receipt = sign_receipt(receipt, self._secret)
        write_receipt(receipt, self._receipt_dir)
        output = {r.action: r.output for r in rollback_results if r.success}
        return (
            RunResult(
                success=all_success,
                workflow=f"rollback:{original_receipt.workflow}",
                output=output,
            ),
            receipt,
        )
```

### Step 4: Add `rollback_enabled=False` default test to `tests/test_client.py`

```python
def test_rollback_disabled_by_default():
    client = EnactClient()
    assert client._rollback_enabled is False
```

### Step 5: Run tests

```bash
pytest tests/test_rollback.py -v
pytest tests/test_client.py -v
```
Expected: all pass.

### Step 6: Commit

```bash
git add enact/client.py tests/test_rollback.py tests/test_client.py
git commit -m "feat: add EnactClient.rollback() with premium gate and rollback receipt"
```

---

## Cycle 8: Full suite verification

### Step 1: Run full test suite

```bash
pytest tests/ -v
```
Expected: 140+ tests, 0 failures.

If any failures: fix before proceeding. Do not commit a broken suite.

### Step 2: Verify rollback_data doesn't break existing ActionResult serialization

```bash
python -c "
from enact.models import ActionResult
import json
a = ActionResult(action='x', system='y', success=True, output={'z': 1})
print(json.dumps(a.model_dump(), indent=2))
assert a.rollback_data == {}
print('OK — backward compat confirmed')
"
```

### Step 3: Commit

```bash
git add .
git commit -m "feat: rollback — full suite passing"
```

---

## A.9 Success Criteria

- [ ] `rollback_data` field on all `ActionResult` instances, default `{}`
- [ ] `load_receipt()` in `receipt.py`
- [ ] `close_pr`, `close_issue`, `create_branch_from_sha` on GitHubConnector
- [ ] All existing GitHub/Postgres methods populate `rollback_data` on fresh actions
- [ ] `execute_rollback_action()` in `enact/rollback.py` — dispatches correctly
- [ ] `EnactClient.rollback(run_id)` — gated, best-effort, produces signed receipt
- [ ] `pytest tests/ -v` — 140+ tests, 0 failures
- [ ] No existing tests broken

## Known Limitations (v1)

- `update_row` rollback only restores the first matched row's values — multi-row updates are partially handled (document this)
- `merge_pr` is irreversible — recorded in rollback receipt as failure
- PK detection for `insert_row` rollback uses `id` column or first column — document this convention
- No rollback for systems outside `github` and `postgres` (returns failure with clear error)

---

## Appendix: Adding Rollback Support to a New Connector

When a new connector ships (e.g., `SlackConnector`, `HubSpotConnector`), rollback support requires **three changes**. The pattern is identical for every connector.

### Step 1: Populate `rollback_data` in each mutating method

Every mutating method on the connector must capture pre-action state and include it in the `ActionResult`:

```python
# Example: SlackConnector.send_message()
def send_message(self, channel: str, text: str) -> ActionResult:
    ...
    # For IRREVERSIBLE actions: rollback_data stays empty
    return ActionResult(
        action="send_message",
        system="slack",
        success=True,
        output={"ts": message.ts, "already_done": False},
        rollback_data={},  # Can't unsend a Slack message
    )

# Example: HubSpotConnector.create_contact()
def create_contact(self, email: str, name: str) -> ActionResult:
    ...
    return ActionResult(
        action="create_contact",
        system="hubspot",
        success=True,
        output={"contact_id": contact.id, "already_done": False},
        rollback_data={
            "contact_id": contact.id,   # needed to delete on rollback
        },
    )
```

**Rule:** Fresh actions get `rollback_data` with everything the inverse needs. Already-done noops get `rollback_data={}` (no state change happened, nothing to undo).

### Step 2: Classify each action in `enact/rollback.py`

Add to the appropriate set at the top of `rollback.py`:

```python
_IRREVERSIBLE = {
    ("github", "merge_pr"),
    ("github", "push_commit"),
    ("slack", "send_message"),    # Can't unsend — add here
    ("slack", "send_dm"),         # Same
}

_READ_ONLY = {
    ("postgres", "select_rows"),
    ("hubspot", "get_contact"),   # Read-only — add here
    ("slack", "get_channel"),     # Read-only — add here
}
```

**Rule:** If the action changes state AND it can't be reversed → `_IRREVERSIBLE`. If it reads state only → `_READ_ONLY`. If it can be reversed → leave it out (handled in Step 3).

### Step 3: Add a dispatch function and wire it in

Add a `_rollback_<system>()` function (copy the pattern from `_rollback_github`):

```python
def _rollback_hubspot(action: str, rd: dict, connector) -> ActionResult:
    try:
        if action == "create_contact":
            return connector.delete_contact(contact_id=rd["contact_id"])
        elif action == "update_deal":
            return connector.update_deal(deal_id=rd["deal_id"], data=rd["old_values"])
        else:
            return ActionResult(
                action=f"rollback_{action}",
                system="hubspot",
                success=False,
                output={"error": f"No rollback handler for hubspot.{action}"},
            )
    except Exception as e:
        return ActionResult(
            action=f"rollback_{action}",
            system="hubspot",
            success=False,
            output={"error": f"Rollback failed for hubspot.{action}: {str(e)}"},
        )
```

Then wire it in `execute_rollback_action()`:

```python
    if action_result.system == "github":
        return _rollback_github(action_result.action, rd, connector)
    elif action_result.system == "postgres":
        return _rollback_postgres(action_result.action, rd, connector)
    elif action_result.system == "hubspot":     # ADD THIS
        return _rollback_hubspot(action_result.action, rd, connector)
    else:
        return ActionResult(...)  # generic no-handler failure
```

### Step 4: Add inverse methods to the connector if needed

Some rollbacks need a new inverse method that doesn't exist yet:

| Original action | Inverse method | Already exists? |
|----------------|----------------|-----------------|
| `create_contact` | `delete_contact` | Probably no — add it |
| `update_deal` | `update_deal` | Yes — reuse with old values |
| `create_task` | `delete_task` | Probably no — add it |

New inverse methods follow the same connector conventions: allowlist-first, `already_done` flag, `try/except` error handling.

### Step 5: Tests

Add to the connector's test file (same class as the mutating method):
```python
# Assert rollback_data is populated on fresh action
assert result.rollback_data["contact_id"] == 42

# Assert rollback_data is empty on noop
assert result.rollback_data == {}
```

Add to `tests/test_rollback.py` under a new class (e.g., `TestRollbackHubSpot`):
```python
def test_rollback_create_contact_calls_delete_contact(self):
    connector = MagicMock()
    connector.delete_contact.return_value = ActionResult(
        action="delete_contact", system="hubspot", success=True, output={}
    )
    action = ActionResult(
        action="create_contact", system="hubspot", success=True,
        output={"contact_id": 42}, rollback_data={"contact_id": 42},
    )
    result = execute_rollback_action(action, {"hubspot": connector})
    connector.delete_contact.assert_called_once_with(contact_id=42)
    assert result.success is True
```

### Checklist for each new connector

- [ ] Every mutating method populates `rollback_data` on fresh actions (`{}` on noops)
- [ ] Irreversible actions added to `_IRREVERSIBLE` in `rollback.py`
- [ ] Read-only actions added to `_READ_ONLY` in `rollback.py`
- [ ] `_rollback_<system>()` function written with `try/except`
- [ ] Wired into `execute_rollback_action()` dispatch
- [ ] Inverse methods added to connector if needed
- [ ] Tests added: `rollback_data` shape in connector tests + dispatch tests in `test_rollback.py`
