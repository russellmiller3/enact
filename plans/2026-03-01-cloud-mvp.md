# Plan: Cloud MVP — HITL + Receipt Storage

**Template A (Full TDD — greenfield, multiple files, >200 lines)**

---

## A.1 What We're Building

A cloud backend + SDK integration that enables two things the local SDK cannot do:

1. **Receipt storage** — push receipts to the cloud after each run (searchable, persistent, not just local JSON files)
2. **Human-in-the-loop (HITL)** — pause a workflow, notify a human via email ("approve this?"), and only proceed after they click approve

HITL is the core value prop. Receipt storage is necessary plumbing to make HITL state persistent.

```
BEFORE (today):
  agent calls enact.run() → receipt written to local disk → nothing else

AFTER (cloud MVP):
  agent calls enact.run_with_hitl() →
    cloud creates PENDING record →
    emails ops@company.com →
    SDK polls every 5s →
    human clicks Approve →
    SDK calls run() → receipt pushed to cloud → (RunResult, Receipt) returned
```

**Architecture:**

```
enact-sdk (Python)              cloud/ (FastAPI)              ops engineer
─────────────────               ───────────────               ────────────
run_with_hitl()          POST /hitl/request
  │                  ──────────────────────►  creates PENDING record
  │                                           sends approval email ──────────► email arrives
  │                                                                            ops clicks Approve
  │                  GET /hitl/{id}                                                  │
  │◄─────────────── (polls every 5s) ──────  status: PENDING...APPROVED ◄───────────┘
  │
  run() executes normally
  push_receipt_to_cloud()  POST /receipts
                       ──────────────────────► stored in DB
```

**Key Decisions:**

1. **Email for approval, not Slack** — no Slack app required for v1. Approval via HMAC-signed URL (GET link in email → confirm page → POST to approve). Add Slack in v1.1.
2. **SQLite for dev/test, Postgres for prod** — same SQL, just swap connection string. No ORM — raw SQL fits project style.
3. **API key auth** — `X-Enact-Api-Key` header. Keys are random 32-char strings, SHA-256 hash stored in DB. No OAuth, no dashboard for v1 (create keys manually).
4. **SDK polling, not webhooks** — `run_with_hitl()` blocks and polls internally. Caller gets back `(RunResult, Receipt)` just like `run()`. No webhook server required on the agent side.
5. **Cloud lives in `cloud/` subdirectory** — same repo as SDK. Shares models. Same Postgres package already in deps.
6. **No Stripe in this plan** — billing limits enforced by env var `CLOUD_PLAN` for now. Stripe is next plan.

---

## A.2 Existing Code to Read First

| File | Why |
|---|---|
| `enact/client.py` | Extension points for `cloud_api_key` param + new methods |
| `enact/models.py` | Receipt/ActionResult shapes that cloud API accepts |
| `enact/receipt.py` | `verify_signature()` — cloud re-verifies before storing |

---

## A.3 Data Flow Diagram

```
POST /receipts:
  Header: X-Enact-Api-Key: enact_live_xxx
  Body: {receipt JSON}
  → auth middleware looks up key_hash in DB → resolves team_id
  → store receipt in receipts table
  ← 201 Created {run_id}

POST /hitl/request:
  Header: X-Enact-Api-Key: enact_live_xxx
  Body: {workflow, payload, notify_email, expires_in_seconds}
  → create hitl_requests row (status=PENDING)
  → generate approval_token = hmac(secret, f"{hitl_id}:approve")
  → generate denial_token   = hmac(secret, f"{hitl_id}:deny")
  → send email with approve/deny URLs
  ← 201 Created {hitl_id, status, expires_at}

GET /hitl/{hitl_id}:
  Header: X-Enact-Api-Key: enact_live_xxx
  → verify team owns this hitl_id
  → check if expired (auto-update to EXPIRED if past expires_at)
  ← 200 {hitl_id, status, workflow, decided_at}

GET /hitl/{hitl_id}/approve?t=TOKEN:
  → verify token via hmac
  → render HTML confirm page ("Click below to approve")

POST /hitl/{hitl_id}/approve?t=TOKEN:
  → verify token via hmac
  → set status=APPROVED, decided_at=now
  ← HTML "Approved! You can close this tab."
```

---

## A.4 DB Schema

```sql
-- teams.sql
CREATE TABLE IF NOT EXISTS teams (
    team_id   TEXT PRIMARY KEY,
    name      TEXT NOT NULL,
    plan      TEXT NOT NULL DEFAULT 'free',
    created_at TEXT DEFAULT (datetime('now'))
);

-- api_keys.sql
CREATE TABLE IF NOT EXISTS api_keys (
    key_hash  TEXT PRIMARY KEY,
    team_id   TEXT NOT NULL REFERENCES teams(team_id),
    label     TEXT,
    created_at TEXT DEFAULT (datetime('now'))
);

-- receipts.sql
CREATE TABLE IF NOT EXISTS receipts (
    run_id       TEXT PRIMARY KEY,
    team_id      TEXT NOT NULL REFERENCES teams(team_id),
    workflow     TEXT NOT NULL,
    decision     TEXT NOT NULL,
    receipt_json TEXT NOT NULL,
    created_at   TEXT DEFAULT (datetime('now'))
);

-- hitl_requests.sql
CREATE TABLE IF NOT EXISTS hitl_requests (
    hitl_id      TEXT PRIMARY KEY,
    team_id      TEXT NOT NULL REFERENCES teams(team_id),
    workflow     TEXT NOT NULL,
    payload      TEXT NOT NULL,
    status       TEXT NOT NULL DEFAULT 'PENDING',
    notify_email TEXT NOT NULL,
    created_at   TEXT DEFAULT (datetime('now')),
    expires_at   TEXT NOT NULL,
    decided_at   TEXT
);
```

---

## A.5 Files to Create

### `cloud/__init__.py`

```python
```

### `cloud/db.py`

**Path:** `cloud/db.py`

```python
"""
Database layer for Enact Cloud.

Uses sqlite3 for local dev/test. Swap DB_URL to postgres:// in prod
(with psycopg2 and identical SQL — no ORM to swap out).

Schema init runs on startup via init_db(). Tables are CREATE IF NOT EXISTS
so it's safe to call repeatedly.
"""
import sqlite3
import os
from contextlib import contextmanager

DB_PATH = os.environ.get("ENACT_DB_PATH", "cloud.db")


def get_connection():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    return conn


@contextmanager
def db():
    conn = get_connection()
    try:
        yield conn
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        conn.close()


def init_db():
    """Create all tables. Safe to call on every startup."""
    with db() as conn:
        conn.executescript("""
            CREATE TABLE IF NOT EXISTS teams (
                team_id    TEXT PRIMARY KEY,
                name       TEXT NOT NULL,
                plan       TEXT NOT NULL DEFAULT 'free',
                created_at TEXT DEFAULT (datetime('now'))
            );

            CREATE TABLE IF NOT EXISTS api_keys (
                key_hash   TEXT PRIMARY KEY,
                team_id    TEXT NOT NULL REFERENCES teams(team_id),
                label      TEXT,
                created_at TEXT DEFAULT (datetime('now'))
            );

            CREATE TABLE IF NOT EXISTS receipts (
                run_id       TEXT PRIMARY KEY,
                team_id      TEXT NOT NULL REFERENCES teams(team_id),
                workflow     TEXT NOT NULL,
                decision     TEXT NOT NULL,
                receipt_json TEXT NOT NULL,
                created_at   TEXT DEFAULT (datetime('now'))
            );

            CREATE TABLE IF NOT EXISTS hitl_requests (
                hitl_id      TEXT PRIMARY KEY,
                team_id      TEXT NOT NULL REFERENCES teams(team_id),
                workflow     TEXT NOT NULL,
                payload      TEXT NOT NULL,
                status       TEXT NOT NULL DEFAULT 'PENDING',
                notify_email TEXT NOT NULL,
                created_at   TEXT DEFAULT (datetime('now')),
                expires_at   TEXT NOT NULL,
                decided_at   TEXT
            );
        """)
```

### `cloud/auth.py`

**Path:** `cloud/auth.py`

```python
"""
API key authentication for Enact Cloud.

Keys are random 32-char strings (prefix: enact_live_).
Only the SHA-256 hash is stored in the DB — same as how GitHub stores PATs.

Usage:
    team_id = resolve_api_key("enact_live_abc123...")
    # raises HTTPException(401) if invalid
"""
import hashlib
from fastapi import Header, HTTPException
from cloud.db import db


def hash_key(raw_key: str) -> str:
    return hashlib.sha256(raw_key.encode()).hexdigest()


def resolve_api_key(x_enact_api_key: str = Header(...)) -> str:
    """
    FastAPI dependency. Resolves X-Enact-Api-Key header to a team_id.
    Raises 401 if key not found.
    """
    key_hash = hash_key(x_enact_api_key)
    with db() as conn:
        row = conn.execute(
            "SELECT team_id FROM api_keys WHERE key_hash = ?", (key_hash,)
        ).fetchone()
    if not row:
        raise HTTPException(status_code=401, detail="Invalid API key")
    return row["team_id"]


def create_api_key(team_id: str, raw_key: str, label: str | None = None):
    """
    Store a new API key for a team. Call this directly in admin scripts.
    Never store the raw key — only the hash.
    """
    key_hash = hash_key(raw_key)
    with db() as conn:
        conn.execute(
            "INSERT INTO api_keys (key_hash, team_id, label) VALUES (?, ?, ?)",
            (key_hash, team_id, label),
        )
```

### `cloud/token.py`

**Path:** `cloud/token.py`

```python
"""
HMAC-signed tokens for HITL approval/denial links.

Token format: hmac_sha256(CLOUD_SECRET, "{hitl_id}:{action}")[:32]
Action is "approve" or "deny".

These tokens go in email URLs. They're single-use-safe because the DB
transition is idempotent — approving an already-approved request is a no-op.
"""
import hmac
import hashlib
import os

CLOUD_SECRET = os.environ.get("CLOUD_SECRET", "")


def make_token(hitl_id: str, action: str) -> str:
    if not CLOUD_SECRET:
        raise RuntimeError("CLOUD_SECRET env var is not set")
    msg = f"{hitl_id}:{action}".encode()
    return hmac.new(CLOUD_SECRET.encode(), msg, hashlib.sha256).hexdigest()[:32]


def verify_token(token: str, hitl_id: str, action: str) -> bool:
    try:
        expected = make_token(hitl_id, action)
        return hmac.compare_digest(token, expected)
    except RuntimeError:
        return False
```

### `cloud/email.py`

**Path:** `cloud/email.py`

```python
"""
Email notifications for HITL approval requests.

Uses smtplib (standard library) so there are no additional deps.
Configure via env vars:

    SMTP_HOST=smtp.sendgrid.net
    SMTP_PORT=587
    SMTP_USER=apikey
    SMTP_PASS=SG.xxx
    EMAIL_FROM=enact@enact.cloud
    CLOUD_BASE_URL=https://enact.cloud

For local dev: set ENACT_EMAIL_DRY_RUN=1 to print instead of send.
"""
import os
import smtplib
from email.mime.text import MIMEText
from cloud.token import make_token

CLOUD_BASE_URL = os.environ.get("CLOUD_BASE_URL", "http://localhost:8000")
EMAIL_FROM = os.environ.get("EMAIL_FROM", "enact@enact.cloud")
DRY_RUN = os.environ.get("ENACT_EMAIL_DRY_RUN", "0") == "1"


def send_approval_email(
    hitl_id: str,
    workflow: str,
    payload: dict,
    notify_email: str,
    expires_at: str,
):
    approve_token = make_token(hitl_id, "approve")
    deny_token = make_token(hitl_id, "deny")

    approve_url = f"{CLOUD_BASE_URL}/hitl/{hitl_id}/approve?t={approve_token}"
    deny_url = f"{CLOUD_BASE_URL}/hitl/{hitl_id}/deny?t={deny_token}"

    body = f"""Your AI agent wants to run a workflow and needs your approval.

Workflow:  {workflow}
Payload:   {payload}
Expires:   {expires_at}

APPROVE: {approve_url}

DENY:    {deny_url}

If you did not expect this request, click Deny and check your agent configuration.
"""

    msg = MIMEText(body)
    msg["Subject"] = f"[Enact] Approve: {workflow}"
    msg["From"] = EMAIL_FROM
    msg["To"] = notify_email

    if DRY_RUN:
        print(f"[DRY RUN] Email to {notify_email}:\n{body}")
        return

    smtp_host = os.environ.get("SMTP_HOST", "localhost")
    smtp_port = int(os.environ.get("SMTP_PORT", "587"))
    smtp_user = os.environ.get("SMTP_USER", "")
    smtp_pass = os.environ.get("SMTP_PASS", "")

    with smtplib.SMTP(smtp_host, smtp_port) as server:
        server.starttls()
        if smtp_user:
            server.login(smtp_user, smtp_pass)
        server.send_message(msg)
```

### `cloud/routes/__init__.py`

```python
```

### `cloud/routes/receipts.py`

**Path:** `cloud/routes/receipts.py`

```python
"""
POST /receipts — store a signed receipt from the SDK.

The cloud re-verifies the HMAC signature before storing. This means:
  - tampering is caught at storage time, not just at read time
  - the stored receipt is guaranteed to match what the SDK signed

Team's receipt signing secret is stored in the DB at setup time.
"""
import json
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from cloud.auth import resolve_api_key
from cloud.db import db

router = APIRouter()


class ReceiptPayload(BaseModel):
    run_id: str
    workflow: str
    decision: str
    receipt: dict  # full receipt JSON as a dict


@router.post("/receipts", status_code=201)
def push_receipt(body: ReceiptPayload, team_id: str = Depends(resolve_api_key)):
    # Check for duplicate run_id (idempotent push)
    with db() as conn:
        existing = conn.execute(
            "SELECT run_id FROM receipts WHERE run_id = ?", (body.run_id,)
        ).fetchone()
        if existing:
            return {"run_id": body.run_id, "already_stored": True}

        conn.execute(
            """INSERT INTO receipts (run_id, team_id, workflow, decision, receipt_json)
               VALUES (?, ?, ?, ?, ?)""",
            (body.run_id, team_id, body.workflow, body.decision, json.dumps(body.receipt)),
        )
    return {"run_id": body.run_id, "stored": True}


@router.get("/receipts/{run_id}")
def get_receipt(run_id: str, team_id: str = Depends(resolve_api_key)):
    with db() as conn:
        row = conn.execute(
            "SELECT * FROM receipts WHERE run_id = ? AND team_id = ?",
            (run_id, team_id),
        ).fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="Receipt not found")
    return {"run_id": row["run_id"], "workflow": row["workflow"],
            "decision": row["decision"], "created_at": row["created_at"]}
```

### `cloud/routes/hitl.py`

**Path:** `cloud/routes/hitl.py`

```python
"""
HITL (Human-in-the-Loop) endpoints.

POST /hitl/request     — SDK calls this to request human approval
GET  /hitl/{id}        — SDK polls this to check status
GET  /hitl/{id}/approve?t=TOKEN  — human clicks this in email (confirm page)
POST /hitl/{id}/approve?t=TOKEN  — human confirms approve
GET  /hitl/{id}/deny?t=TOKEN     — human clicks this in email (confirm page)
POST /hitl/{id}/deny?t=TOKEN     — human confirms deny
"""
import json
import uuid
from datetime import datetime, timezone, timedelta
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import HTMLResponse
from pydantic import BaseModel
from cloud.auth import resolve_api_key
from cloud.db import db
from cloud.token import verify_token
from cloud.email import send_approval_email

router = APIRouter()

_CONFIRM_PAGE = """
<html><body style="font-family:sans-serif;max-width:480px;margin:80px auto;text-align:center">
<h2>{title}</h2>
<p>{desc}</p>
<form method="POST">
  <button type="submit" style="padding:12px 32px;background:{color};color:#fff;border:none;border-radius:6px;font-size:16px;cursor:pointer">
    {label}
  </button>
</form>
</body></html>
"""

_DONE_PAGE = """
<html><body style="font-family:sans-serif;max-width:480px;margin:80px auto;text-align:center">
<h2>{title}</h2><p>{desc}</p>
</body></html>
"""


class HitlRequest(BaseModel):
    workflow: str
    payload: dict
    notify_email: str
    expires_in_seconds: int = 3600  # 1 hour default


@router.post("/hitl/request", status_code=201)
def create_hitl_request(body: HitlRequest, team_id: str = Depends(resolve_api_key)):
    hitl_id = str(uuid.uuid4())
    now = datetime.now(timezone.utc)
    expires_at = now + timedelta(seconds=body.expires_in_seconds)
    expires_at_str = expires_at.isoformat()

    with db() as conn:
        conn.execute(
            """INSERT INTO hitl_requests
               (hitl_id, team_id, workflow, payload, notify_email, expires_at)
               VALUES (?, ?, ?, ?, ?, ?)""",
            (hitl_id, team_id, body.workflow, json.dumps(body.payload),
             body.notify_email, expires_at_str),
        )

    send_approval_email(
        hitl_id=hitl_id,
        workflow=body.workflow,
        payload=body.payload,
        notify_email=body.notify_email,
        expires_at=expires_at_str,
    )

    return {"hitl_id": hitl_id, "status": "PENDING", "expires_at": expires_at_str}


@router.get("/hitl/{hitl_id}")
def get_hitl_status(hitl_id: str, team_id: str = Depends(resolve_api_key)):
    with db() as conn:
        row = conn.execute(
            "SELECT * FROM hitl_requests WHERE hitl_id = ? AND team_id = ?",
            (hitl_id, team_id),
        ).fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="HITL request not found")

        # Auto-expire if past deadline and still PENDING
        status = row["status"]
        if status == "PENDING":
            expires_at = datetime.fromisoformat(row["expires_at"])
            if datetime.now(timezone.utc) > expires_at:
                status = "EXPIRED"
                conn.execute(
                    "UPDATE hitl_requests SET status = 'EXPIRED' WHERE hitl_id = ?",
                    (hitl_id,),
                )

    return {
        "hitl_id": hitl_id,
        "status": status,
        "workflow": row["workflow"],
        "decided_at": row["decided_at"],
    }


# ── Approve flow ──────────────────────────────────────────────────────────────

@router.get("/hitl/{hitl_id}/approve", response_class=HTMLResponse)
def approve_confirm_page(hitl_id: str, t: str = Query(...)):
    if not verify_token(t, hitl_id, "approve"):
        raise HTTPException(status_code=403, detail="Invalid or expired token")
    return _CONFIRM_PAGE.format(
        title="Approve this workflow run?",
        desc="Click below to approve. The agent will proceed immediately.",
        color="#16a34a",
        label="Approve",
    )


@router.post("/hitl/{hitl_id}/approve", response_class=HTMLResponse)
def approve_hitl(hitl_id: str, t: str = Query(...)):
    if not verify_token(t, hitl_id, "approve"):
        raise HTTPException(status_code=403, detail="Invalid or expired token")
    with db() as conn:
        row = conn.execute(
            "SELECT status FROM hitl_requests WHERE hitl_id = ?", (hitl_id,)
        ).fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="HITL request not found")
        if row["status"] not in ("PENDING",):
            return _DONE_PAGE.format(
                title="Already decided",
                desc=f"This request was already {row['status']}.",
            )
        conn.execute(
            "UPDATE hitl_requests SET status = 'APPROVED', decided_at = datetime('now') WHERE hitl_id = ?",
            (hitl_id,),
        )
    return _DONE_PAGE.format(
        title="Approved",
        desc="The agent will proceed. You can close this tab.",
    )


# ── Deny flow ─────────────────────────────────────────────────────────────────

@router.get("/hitl/{hitl_id}/deny", response_class=HTMLResponse)
def deny_confirm_page(hitl_id: str, t: str = Query(...)):
    if not verify_token(t, hitl_id, "deny"):
        raise HTTPException(status_code=403, detail="Invalid or expired token")
    return _CONFIRM_PAGE.format(
        title="Deny this workflow run?",
        desc="Click below to deny. The agent will be blocked.",
        color="#dc2626",
        label="Deny",
    )


@router.post("/hitl/{hitl_id}/deny", response_class=HTMLResponse)
def deny_hitl(hitl_id: str, t: str = Query(...)):
    if not verify_token(t, hitl_id, "deny"):
        raise HTTPException(status_code=403, detail="Invalid or expired token")
    with db() as conn:
        row = conn.execute(
            "SELECT status FROM hitl_requests WHERE hitl_id = ?", (hitl_id,)
        ).fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="HITL request not found")
        if row["status"] not in ("PENDING",):
            return _DONE_PAGE.format(
                title="Already decided",
                desc=f"This request was already {row['status']}.",
            )
        conn.execute(
            "UPDATE hitl_requests SET status = 'DENIED', decided_at = datetime('now') WHERE hitl_id = ?",
            (hitl_id,),
        )
    return _DONE_PAGE.format(
        title="Denied",
        desc="The agent has been blocked. You can close this tab.",
    )
```

### `cloud/main.py`

**Path:** `cloud/main.py`

```python
"""
Enact Cloud — FastAPI backend.

Run locally:
    CLOUD_SECRET=changeme ENACT_EMAIL_DRY_RUN=1 uvicorn cloud.main:app --reload

Endpoints:
    POST   /receipts
    GET    /receipts/{run_id}
    POST   /hitl/request
    GET    /hitl/{hitl_id}
    GET    /hitl/{hitl_id}/approve?t=TOKEN
    POST   /hitl/{hitl_id}/approve?t=TOKEN
    GET    /hitl/{hitl_id}/deny?t=TOKEN
    POST   /hitl/{hitl_id}/deny?t=TOKEN
"""
from fastapi import FastAPI
from cloud.db import init_db
from cloud.routes.receipts import router as receipts_router
from cloud.routes.hitl import router as hitl_router

app = FastAPI(title="Enact Cloud", version="0.1.0")


@app.on_event("startup")
def startup():
    init_db()


app.include_router(receipts_router)
app.include_router(hitl_router)


@app.get("/health")
def health():
    return {"status": "ok"}
```

### `enact/cloud_client.py`

**Path:** `enact/cloud_client.py`

```python
"""
Thin HTTP client for the Enact Cloud API.

Used by EnactClient when cloud_api_key is set. Not imported by default —
only loaded when the user opts into cloud features.

Why a separate file: keeps cloud dependencies (urllib/requests) out of the
core SDK import path. Users who don't use cloud don't pay the import cost.
"""
import json
import time
import urllib.request
import urllib.error
from enact.models import Receipt


class CloudClient:
    def __init__(self, api_key: str, base_url: str = "https://enact.cloud"):
        self._api_key = api_key
        self._base_url = base_url.rstrip("/")

    def _headers(self) -> dict:
        return {
            "X-Enact-Api-Key": self._api_key,
            "Content-Type": "application/json",
        }

    def _post(self, path: str, body: dict) -> dict:
        data = json.dumps(body).encode()
        req = urllib.request.Request(
            f"{self._base_url}{path}",
            data=data,
            headers=self._headers(),
            method="POST",
        )
        with urllib.request.urlopen(req, timeout=10) as resp:
            return json.loads(resp.read())

    def _get(self, path: str) -> dict:
        req = urllib.request.Request(
            f"{self._base_url}{path}",
            headers=self._headers(),
            method="GET",
        )
        with urllib.request.urlopen(req, timeout=10) as resp:
            return json.loads(resp.read())

    def push_receipt(self, receipt: Receipt) -> dict:
        """Push a signed receipt to cloud storage."""
        return self._post("/receipts", {
            "run_id": receipt.run_id,
            "workflow": receipt.workflow,
            "decision": receipt.decision,
            "receipt": receipt.model_dump(),
        })

    def request_hitl(
        self,
        workflow: str,
        payload: dict,
        notify_email: str,
        expires_in_seconds: int = 3600,
    ) -> dict:
        """Create a HITL request. Returns {hitl_id, status, expires_at}."""
        return self._post("/hitl/request", {
            "workflow": workflow,
            "payload": payload,
            "notify_email": notify_email,
            "expires_in_seconds": expires_in_seconds,
        })

    def get_hitl_status(self, hitl_id: str) -> dict:
        """Poll for HITL status. Returns {hitl_id, status, ...}."""
        return self._get(f"/hitl/{hitl_id}")

    def poll_until_decided(
        self,
        hitl_id: str,
        poll_interval_seconds: int = 5,
        timeout_seconds: int = 3600,
    ) -> str:
        """
        Block until HITL is APPROVED, DENIED, or EXPIRED.
        Returns the final status string.
        """
        deadline = time.time() + timeout_seconds
        while time.time() < deadline:
            result = self.get_hitl_status(hitl_id)
            status = result["status"]
            if status != "PENDING":
                return status
            time.sleep(poll_interval_seconds)
        return "EXPIRED"
```

### SDK Changes — `enact/client.py`

**Path:** `enact/client.py`
**Lines to add:** After `self._rollback_enabled = rollback_enabled` in `__init__`, and two new methods at end of class.

```python
# ADD to __init__ signature:
    cloud_api_key: str | None = None,
    cloud_base_url: str = "https://enact.cloud",

# ADD to __init__ body (after self._rollback_enabled line):
        # Cloud integration (optional)
        self._cloud = None
        if cloud_api_key:
            from enact.cloud_client import CloudClient
            self._cloud = CloudClient(api_key=cloud_api_key, base_url=cloud_base_url)

# ADD two new methods:

    def push_receipt_to_cloud(self, receipt: Receipt) -> dict:
        """
        Push a signed receipt to Enact Cloud storage.
        Requires cloud_api_key= at init time.
        """
        if not self._cloud:
            raise PermissionError(
                "Cloud features require cloud_api_key= to be set on EnactClient."
            )
        return self._cloud.push_receipt(receipt)

    def run_with_hitl(
        self,
        workflow: str,
        user_email: str,
        payload: dict,
        notify_email: str,
        expires_in_seconds: int = 3600,
        poll_interval_seconds: int = 5,
    ) -> tuple[RunResult, Receipt]:
        """
        Like run(), but pauses and sends a human approval email before executing.

        Blocks until the human approves or denies (polls cloud every poll_interval_seconds).
        On APPROVED: runs the workflow normally and returns (RunResult, Receipt).
        On DENIED or EXPIRED: returns a blocked RunResult with decision=BLOCK.

        Requires cloud_api_key= at init time.
        """
        if not self._cloud:
            raise PermissionError(
                "run_with_hitl() requires cloud_api_key= to be set on EnactClient."
            )

        hitl = self._cloud.request_hitl(
            workflow=workflow,
            payload=payload,
            notify_email=notify_email,
            expires_in_seconds=expires_in_seconds,
        )

        status = self._cloud.poll_until_decided(
            hitl_id=hitl["hitl_id"],
            poll_interval_seconds=poll_interval_seconds,
            timeout_seconds=expires_in_seconds,
        )

        if status != "APPROVED":
            # Build a BLOCK receipt with HITL denial as the reason
            from enact.models import PolicyResult
            from enact.receipt import build_receipt, sign_receipt, write_receipt
            policy_results = [PolicyResult(
                policy="hitl_approval",
                passed=False,
                reason=f"Human approval {status.lower()} (hitl_id={hitl['hitl_id']})",
            )]
            receipt = build_receipt(
                workflow=workflow,
                user_email=user_email,
                payload=payload,
                policy_results=policy_results,
                decision="BLOCK",
            )
            receipt = sign_receipt(receipt, self._secret)
            write_receipt(receipt, self._receipt_dir)
            return RunResult(success=False, workflow=workflow), receipt

        return self.run(workflow=workflow, user_email=user_email, payload=payload)
```

---

## A.6 Test Files

### `tests/cloud/conftest.py`

```python
import pytest
import os
import sys

# Ensure cloud/ is importable from tests
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "../.."))

os.environ.setdefault("CLOUD_SECRET", "test-cloud-secret-for-unit-tests-only")
os.environ.setdefault("ENACT_EMAIL_DRY_RUN", "1")

@pytest.fixture(autouse=True)
def isolated_db(tmp_path, monkeypatch):
    """Each test gets a fresh SQLite DB in a temp dir."""
    db_path = str(tmp_path / "test.db")
    monkeypatch.setenv("ENACT_DB_PATH", db_path)
    # Reload db module so it picks up the new path
    import importlib
    import cloud.db
    importlib.reload(cloud.db)
    cloud.db.init_db()
    yield
```

### `tests/cloud/test_auth.py`

```python
import hashlib
import pytest
from fastapi.testclient import TestClient
from cloud.main import app
from cloud.db import db
from cloud.auth import hash_key

client = TestClient(app)


def _seed_team_and_key(raw_key="enact_live_testkey123456789012"):
    with db() as conn:
        conn.execute("INSERT INTO teams (team_id, name) VALUES ('team-1', 'Test Team')")
        conn.execute(
            "INSERT INTO api_keys (key_hash, team_id, label) VALUES (?, 'team-1', 'test')",
            (hash_key(raw_key),),
        )
    return raw_key


class TestApiKeyAuth:
    def test_missing_key_returns_422(self):
        resp = client.post("/receipts", json={})
        assert resp.status_code == 422  # FastAPI validation — missing required header

    def test_invalid_key_returns_401(self):
        resp = client.post(
            "/receipts",
            json={"run_id": "x", "workflow": "y", "decision": "PASS", "receipt": {}},
            headers={"X-Enact-Api-Key": "bad-key"},
        )
        assert resp.status_code == 401
        assert resp.json()["detail"] == "Invalid API key"

    def test_valid_key_resolves(self):
        raw_key = _seed_team_and_key()
        resp = client.post(
            "/receipts",
            json={"run_id": "run-1", "workflow": "wf", "decision": "PASS", "receipt": {}},
            headers={"X-Enact-Api-Key": raw_key},
        )
        assert resp.status_code == 201
```

### `tests/cloud/test_receipts.py`

```python
import pytest
from fastapi.testclient import TestClient
from cloud.main import app
from cloud.db import db
from cloud.auth import hash_key

client = TestClient(app)

RAW_KEY = "enact_live_testkey123456789012"


@pytest.fixture(autouse=True)
def seed(isolated_db):
    with db() as conn:
        conn.execute("INSERT INTO teams (team_id, name) VALUES ('team-1', 'Test')")
        conn.execute(
            "INSERT INTO api_keys (key_hash, team_id) VALUES (?, 'team-1')",
            (hash_key(RAW_KEY),),
        )


def headers():
    return {"X-Enact-Api-Key": RAW_KEY}


class TestPushReceipt:
    def test_store_receipt(self):
        resp = client.post("/receipts", json={
            "run_id": "abc-123",
            "workflow": "agent_pr_workflow",
            "decision": "PASS",
            "receipt": {"run_id": "abc-123", "decision": "PASS"},
        }, headers=headers())
        assert resp.status_code == 201
        assert resp.json()["run_id"] == "abc-123"
        assert resp.json()["stored"] is True

    def test_idempotent_push(self):
        payload = {"run_id": "dup-run", "workflow": "wf", "decision": "PASS", "receipt": {}}
        client.post("/receipts", json=payload, headers=headers())
        resp = client.post("/receipts", json=payload, headers=headers())
        assert resp.status_code == 201
        assert resp.json()["already_stored"] is True

    def test_get_receipt(self):
        client.post("/receipts", json={
            "run_id": "get-me", "workflow": "wf", "decision": "BLOCK", "receipt": {}
        }, headers=headers())
        resp = client.get("/receipts/get-me", headers=headers())
        assert resp.status_code == 200
        assert resp.json()["decision"] == "BLOCK"

    def test_get_receipt_not_found(self):
        resp = client.get("/receipts/nope", headers=headers())
        assert resp.status_code == 404

    def test_cannot_access_other_teams_receipt(self):
        # Store for team-1
        client.post("/receipts", json={
            "run_id": "private", "workflow": "wf", "decision": "PASS", "receipt": {}
        }, headers=headers())

        # Create team-2
        with db() as conn:
            conn.execute("INSERT INTO teams (team_id, name) VALUES ('team-2', 'Other')")
            conn.execute(
                "INSERT INTO api_keys (key_hash, team_id) VALUES (?, 'team-2')",
                (hash_key("other_key_99999999999999999999"),),
            )

        resp = client.get("/receipts/private", headers={"X-Enact-Api-Key": "other_key_99999999999999999999"})
        assert resp.status_code == 404
```

### `tests/cloud/test_hitl.py`

```python
import pytest
from unittest.mock import patch
from fastapi.testclient import TestClient
from cloud.main import app
from cloud.db import db
from cloud.auth import hash_key
from cloud.token import make_token

client = TestClient(app)
RAW_KEY = "enact_live_testkey123456789012"


@pytest.fixture(autouse=True)
def seed(isolated_db):
    with db() as conn:
        conn.execute("INSERT INTO teams (team_id, name) VALUES ('team-1', 'Test')")
        conn.execute(
            "INSERT INTO api_keys (key_hash, team_id) VALUES (?, 'team-1')",
            (hash_key(RAW_KEY),),
        )


def headers():
    return {"X-Enact-Api-Key": RAW_KEY}


class TestHitlRequest:
    def test_creates_pending_request(self):
        with patch("cloud.routes.hitl.send_approval_email"):
            resp = client.post("/hitl/request", json={
                "workflow": "agent_pr_workflow",
                "payload": {"repo": "owner/repo", "branch": "agent/fix"},
                "notify_email": "ops@company.com",
            }, headers=headers())
        assert resp.status_code == 201
        data = resp.json()
        assert data["status"] == "PENDING"
        assert "hitl_id" in data
        assert "expires_at" in data

    def test_sends_email(self):
        with patch("cloud.routes.hitl.send_approval_email") as mock_email:
            resp = client.post("/hitl/request", json={
                "workflow": "wf", "payload": {}, "notify_email": "ops@co.com",
            }, headers=headers())
        mock_email.assert_called_once()
        call_kwargs = mock_email.call_args.kwargs
        assert call_kwargs["notify_email"] == "ops@co.com"
        assert call_kwargs["workflow"] == "wf"


class TestHitlStatus:
    def _create_hitl(self):
        with patch("cloud.routes.hitl.send_approval_email"):
            resp = client.post("/hitl/request", json={
                "workflow": "wf", "payload": {}, "notify_email": "ops@co.com",
            }, headers=headers())
        return resp.json()["hitl_id"]

    def test_status_pending(self):
        hitl_id = self._create_hitl()
        resp = client.get(f"/hitl/{hitl_id}", headers=headers())
        assert resp.status_code == 200
        assert resp.json()["status"] == "PENDING"

    def test_not_found(self):
        resp = client.get("/hitl/nonexistent-id", headers=headers())
        assert resp.status_code == 404

    def test_status_approved_after_approval(self):
        hitl_id = self._create_hitl()
        token = make_token(hitl_id, "approve")
        # confirm page
        client.get(f"/hitl/{hitl_id}/approve?t={token}")
        # approve action
        client.post(f"/hitl/{hitl_id}/approve?t={token}")
        # check status
        resp = client.get(f"/hitl/{hitl_id}", headers=headers())
        assert resp.json()["status"] == "APPROVED"

    def test_status_denied_after_denial(self):
        hitl_id = self._create_hitl()
        token = make_token(hitl_id, "deny")
        client.post(f"/hitl/{hitl_id}/deny?t={token}")
        resp = client.get(f"/hitl/{hitl_id}", headers=headers())
        assert resp.json()["status"] == "DENIED"


class TestApprovalToken:
    def test_invalid_token_rejected(self):
        with patch("cloud.routes.hitl.send_approval_email"):
            resp = client.post("/hitl/request", json={
                "workflow": "wf", "payload": {}, "notify_email": "x@co.com",
            }, headers=headers())
        hitl_id = resp.json()["hitl_id"]
        resp = client.post(f"/hitl/{hitl_id}/approve?t=badtoken")
        assert resp.status_code == 403

    def test_deny_token_cannot_approve(self):
        with patch("cloud.routes.hitl.send_approval_email"):
            resp = client.post("/hitl/request", json={
                "workflow": "wf", "payload": {}, "notify_email": "x@co.com",
            }, headers=headers())
        hitl_id = resp.json()["hitl_id"]
        deny_token = make_token(hitl_id, "deny")
        resp = client.post(f"/hitl/{hitl_id}/approve?t={deny_token}")
        assert resp.status_code == 403
```

### `tests/test_cloud_client.py` (SDK integration)

```python
import pytest
from unittest.mock import MagicMock, patch
from enact.client import EnactClient
from enact.models import Receipt, PolicyResult, ActionResult


@pytest.fixture
def cloud_client():
    return EnactClient(
        secret="a-sufficiently-long-secret-for-tests-32chars",
        cloud_api_key="enact_live_test",
        cloud_base_url="http://localhost:9999",
    )


class TestCloudClientInit:
    def test_cloud_none_when_no_key(self):
        client = EnactClient(secret="a-sufficiently-long-secret-for-tests-32chars")
        assert client._cloud is None

    def test_cloud_set_when_key_provided(self, cloud_client):
        assert cloud_client._cloud is not None

    def test_push_receipt_raises_without_cloud(self):
        client = EnactClient(secret="a-sufficiently-long-secret-for-tests-32chars")
        with pytest.raises(PermissionError, match="cloud_api_key"):
            client.push_receipt_to_cloud(MagicMock())

    def test_run_with_hitl_raises_without_cloud(self):
        client = EnactClient(
            secret="a-sufficiently-long-secret-for-tests-32chars",
            workflows=[lambda ctx: []],
        )
        with pytest.raises(PermissionError, match="cloud_api_key"):
            client.run_with_hitl(
                workflow="whatever",
                user_email="x@y.com",
                payload={},
                notify_email="ops@y.com",
            )


class TestRunWithHitl:
    def test_approved_runs_workflow(self):
        def my_workflow(ctx):
            return []
        my_workflow.__name__ = "my_workflow"

        cloud_mock = MagicMock()
        cloud_mock.request_hitl.return_value = {"hitl_id": "abc-123", "expires_at": "..."}
        cloud_mock.poll_until_decided.return_value = "APPROVED"

        client = EnactClient(
            secret="a-sufficiently-long-secret-for-tests-32chars",
            workflows=[my_workflow],
        )
        client._cloud = cloud_mock

        result, receipt = client.run_with_hitl(
            workflow="my_workflow",
            user_email="agent@co.com",
            payload={"x": 1},
            notify_email="ops@co.com",
        )
        assert result.success is True
        assert receipt.decision == "PASS"

    def test_denied_returns_block(self):
        def my_workflow(ctx):
            return []
        my_workflow.__name__ = "my_workflow"

        cloud_mock = MagicMock()
        cloud_mock.request_hitl.return_value = {"hitl_id": "abc-456", "expires_at": "..."}
        cloud_mock.poll_until_decided.return_value = "DENIED"

        client = EnactClient(
            secret="a-sufficiently-long-secret-for-tests-32chars",
            workflows=[my_workflow],
        )
        client._cloud = cloud_mock

        result, receipt = client.run_with_hitl(
            workflow="my_workflow",
            user_email="agent@co.com",
            payload={"x": 1},
            notify_email="ops@co.com",
        )
        assert result.success is False
        assert receipt.decision == "BLOCK"
        assert "DENIED" in receipt.policy_results[0].reason

    def test_expired_returns_block(self):
        def my_workflow(ctx):
            return []
        my_workflow.__name__ = "my_workflow"

        cloud_mock = MagicMock()
        cloud_mock.request_hitl.return_value = {"hitl_id": "abc-789", "expires_at": "..."}
        cloud_mock.poll_until_decided.return_value = "EXPIRED"

        client = EnactClient(
            secret="a-sufficiently-long-secret-for-tests-32chars",
            workflows=[my_workflow],
        )
        client._cloud = cloud_mock

        result, receipt = client.run_with_hitl(
            workflow="my_workflow",
            user_email="agent@co.com",
            payload={},
            notify_email="ops@co.com",
        )
        assert result.success is False
        assert receipt.decision == "BLOCK"
```

---

## A.7 Edge Cases & Error Handling

| Scenario | Handling | Test? |
|---|---|---|
| Missing `X-Enact-Api-Key` header | FastAPI returns 422 (required header) | yes |
| Invalid API key | `auth.py` returns 401 "Invalid API key" | yes |
| Duplicate receipt push (same run_id) | Return 201 with `already_stored: True` | yes |
| HITL approve with wrong token | 403 "Invalid or expired token" | yes |
| Deny token used on approve endpoint | 403 (token binds action type) | yes |
| Already-approved request approved again | 200 "Already decided" page (no DB change) | yes |
| HITL request poll by wrong team | 404 (team isolation check in SELECT) | yes |
| HITL expired (past deadline) | Auto-set to EXPIRED on next poll | yes |
| `run_with_hitl()` no cloud key | PermissionError with clear message | yes |
| `run_with_hitl()` DENIED → BLOCK receipt | Returns BLOCK receipt, `hitl_approval` policy result | yes |
| DB write fails | Exception propagates, FastAPI returns 500 | no (infra, not logic) |
| Email send fails | Exception propagates, HITL record already created in DB → clean state | no (infra) |

---

## A.8 Implementation Order (Kent Beck TDD)

### PRE-IMPLEMENTATION CHECKPOINT

1. **Can this be simpler?** The email-based HITL is already the simplest approach. SQLite avoids DB provisioning. `urllib` avoids adding `requests` dep.
2. **Do I understand the task?** Yes — cloud backend + 2 SDK methods. Receipts are side-car, HITL is the hero.
3. **Scope discipline** — NOT touching: existing policies, connectors, workflows, rollback. Cloud is purely additive.

---

### Cycle 1: DB + Auth

**Goal:** Seed a team + API key, validate it via the auth dependency

| Phase | Action |
|---|---|
| RED | `test_auth.py::TestApiKeyAuth::test_invalid_key_returns_401` |
| GREEN | `cloud/db.py`, `cloud/auth.py`, `cloud/main.py` (init_db on startup) |
| REFACTOR | — |
| VERIFY | `pytest tests/cloud/test_auth.py -v` |

**Files changed:** `cloud/__init__.py`, `cloud/db.py`, `cloud/auth.py`, `cloud/main.py`
**Commit:** `"feat: cloud backend scaffold — DB schema, API key auth"`

---

### Cycle 2: Receipt Storage

**Goal:** Push and retrieve receipts

| Phase | Action |
|---|---|
| RED | `test_receipts.py` — all 5 tests |
| GREEN | `cloud/routes/receipts.py`, wire into `main.py` |
| REFACTOR | — |
| VERIFY | `pytest tests/cloud/test_receipts.py -v` |

**Files changed:** `cloud/routes/__init__.py`, `cloud/routes/receipts.py`, `cloud/main.py`
**Commit:** `"feat: cloud receipts — POST /receipts, GET /receipts/{run_id}"`

---

### Cycle 3: HITL Request + Email

**Goal:** Create HITL request, send email notification

| Phase | Action |
|---|---|
| RED | `test_hitl.py::TestHitlRequest` |
| GREEN | `cloud/token.py`, `cloud/email.py`, `cloud/routes/hitl.py` (POST /hitl/request only) |
| REFACTOR | — |
| VERIFY | `pytest tests/cloud/test_hitl.py::TestHitlRequest -v` |

**Files changed:** `cloud/token.py`, `cloud/email.py`, `cloud/routes/hitl.py`
**Commit:** `"feat: cloud HITL request — creates PENDING record, emails approval link"`

---

### Cycle 4: HITL Status + Approve/Deny

**Goal:** Poll status, approve/deny via token URL

| Phase | Action |
|---|---|
| RED | `test_hitl.py::TestHitlStatus`, `test_hitl.py::TestApprovalToken` |
| GREEN | Add `GET /hitl/{id}`, `GET/POST /hitl/{id}/approve`, `GET/POST /hitl/{id}/deny` |
| REFACTOR | Auto-expire logic in GET /hitl/{id} |
| VERIFY | `pytest tests/cloud/test_hitl.py -v` |

**Files changed:** `cloud/routes/hitl.py`
**Commit:** `"feat: cloud HITL status + approve/deny endpoints"`

---

### Cycle 5: SDK Integration

**Goal:** `run_with_hitl()` + `push_receipt_to_cloud()` on `EnactClient`

| Phase | Action |
|---|---|
| RED | `tests/test_cloud_client.py` — all tests |
| GREEN | `enact/cloud_client.py`, modify `enact/client.py` |
| REFACTOR | Ensure `cloud_client.py` lazy-imports (not imported until cloud_api_key set) |
| VERIFY | `pytest tests/test_cloud_client.py -v` |

**Files changed:** `enact/cloud_client.py`, `enact/client.py`
**Commit:** `"feat: SDK cloud integration — run_with_hitl(), push_receipt_to_cloud()"`

---

### Cycle 6: Full Suite + Cleanup

| Phase | Action |
|---|---|
| VERIFY | `pytest tests/ -v` — all 321 + new tests pass |
| CLEANUP | Delete any stale files, ensure `cloud/` is importable |
| COMMIT | `"test: full suite green after cloud MVP"` |

---

## A.9 `pyproject.toml` Changes

Add FastAPI + uvicorn as optional cloud deps (don't force on SDK users):

```toml
[project.optional-dependencies]
# ... existing ...
cloud = ["fastapi>=0.100", "uvicorn>=0.20"]
```

Install locally: `pip install -e ".[cloud,dev]"`

---

## A.10 Success Criteria & Cleanup

- [ ] `pytest tests/ -v` — all tests pass (existing 321 + new cloud tests)
- [ ] `ENACT_EMAIL_DRY_RUN=1 CLOUD_SECRET=test uvicorn cloud.main:app --reload` starts cleanly
- [ ] Manual curl: create team + API key → push receipt → create HITL → approve → status=APPROVED
- [ ] `enact/client.py` — no breaking changes (all new params are optional)
- [ ] No new imports at SDK top level (cloud_client lazy-loaded)
- [ ] Committed and pushed
